<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>docker</title>
      <link href="/2020/04/04/docker/"/>
      <url>/2020/04/04/docker/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 应用容器引擎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git</title>
      <link href="/2020/04/04/git/"/>
      <url>/2020/04/04/git/</url>
      
        <content type="html"><![CDATA[<p>版本控制：git</p><a id="more"></a><h1 id="git入门"><a href="#git入门" class="headerlink" title="git入门"></a>git入门</h1><h2 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h2><p><img src="/2020/04/04/git/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6.png" alt="版本控制.png"></p><h2 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h2><p>git status : 查看文件状态 （readme.txt红色：说明该文件存放在工作区，没有被git管理起来）</p><p><img src="/2020/04/04/git/%E7%BA%A2%E8%89%B2.png" alt="红色.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git --help </span><br><span class="line"></span><br><span class="line">示例： git --help add 查看add命令的帮助文档</span><br></pre></td></tr></table></figure><p>git add readme.txt  (readme.txt绿色：说明该文件存放在暂存区（unstage区）)</p><p><img src="/2020/04/04/git/%E7%BB%BF%E8%89%B2.png" alt="绿色.png"></p><p>git commit -m “commit readme.txt” (“working tree clean” ：该文件已经在本地库里)</p><p><img src="/2020/04/04/git/%E5%B7%B2%E6%8F%90%E4%BA%A4.png" alt="已提交.png"></p><p>Git 三个区域：</p><p><img src="/2020/04/04/git/git%E5%B7%A5%E4%BD%9C%E5%8C%BA%E5%9F%9F.png" alt="git工作区域.png"></p><h2 id="HEAD、branch和master"><a href="#HEAD、branch和master" class="headerlink" title="HEAD、branch和master"></a>HEAD、branch和master</h2><ul><li>HEAD：当前 commit 的引用</li><li>branch：对commit的引用</li></ul><p>​    git commit:【记录一个’记录节点‘】</p><p><img src="https://user-gold-cdn.xitu.io/2017/11/20/15fd779f983c81e7?imageslim" alt="img"></p><ul><li>master: 默认 branch</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">master ，其实是一个特殊的branch;它是 Git 的默认branch</span><br></pre></td></tr></table></figure><p>git branch -v : 查看分支</p><p>所谓的「默认 branch」，主要有两个特点：</p><ol><li><p>新创建的 repository（仓库）是没有任何 <code>commit</code> 的。但在它创建第一个 <code>commit</code> 时，会把 <code>master</code> 指向它，并把 <code>HEAD</code> 指向 <code>master</code>。</p><p><img src="https://user-gold-cdn.xitu.io/2017/11/20/15fd779f5c66ac9e?imageslim" alt="img"></p></li><li><p>当有人使用 <code>git clone</code> 时，除了从远程仓库把 <code>.git</code> 这个仓库目录下载到工作目录中，还会 <code>checkout</code> （签出） <code>master</code>（<code>checkout</code> 的意思就是把某个 <code>commit</code> 作为当前 <code>commit</code>，把 <code>HEAD</code> 移动过去，并把工作目录的文件内容替换成这个 <code>commit</code> 所对应的内容）。</p></li></ol><p><img src="https://user-gold-cdn.xitu.io/2017/11/20/15fd779f5c191a3f?imageslim" alt="img"></p><h2 id="branch-的通俗化理解"><a href="#branch-的通俗化理解" class="headerlink" title="branch 的通俗化理解"></a>branch 的通俗化理解</h2><p><code>branch</code> 理解为从初始 <code>commit</code> 到 <code>branch</code> 所指向的 <code>commit</code> 之间的所有 <code>commit</code>s 的一个「串」。例如下面这张图：</p><p><img src="https://user-gold-cdn.xitu.io/2017/11/20/15fd779fa5e6970d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>bramch的理解</p><p>1.所有的 <code>branch</code> 之间都是平等的。</p><p><img src="https://user-gold-cdn.xitu.io/2017/11/20/15fd779ff346fbd7?imageslim" alt="img"></p><ol start="2"><li>branch包含了从初始 <code>commit</code>到它的所有路径，而不是一条路径。并且，这些路径之间也是彼此平等的。</li></ol><p><img src="https://user-gold-cdn.xitu.io/2017/11/22/15fe3354a1d3cd26?imageslim" alt="img"></p><p>git checkout -b feature1 [创建feature1分支并且切换分支]</p><p>….</p><p>git commit </p><p><img src="https://user-gold-cdn.xitu.io/2017/11/22/15fe3354a2a32692?imageslim" alt="img"></p><p>git checkout master [切换到master分支]</p><p>….</p><p>git commit </p><p><img src="https://user-gold-cdn.xitu.io/2017/11/22/15fe3354ab0861a7?imageslim" alt="img"></p><h3 id="删除-branch"><a href="#删除-branch" class="headerlink" title="删除 branch"></a>删除 branch</h3><p>git branch -d feature1</p><p><img src="https://user-gold-cdn.xitu.io/2017/11/29/16006b7e3d35fe54?imageslim" alt="img"></p><p>需要说明的有两点：</p><ol><li><p><code>HEAD</code> 指向的 <code>branch</code> 不能删除。如果要删除 <code>HEAD</code> 指向的 <code>branch</code>，需要先用 <code>checkout</code> 把 <code>HEAD</code> 指向其他地方。</p></li><li><p>由于 Git 中的 <code>branch</code> 只是一个引用，所以删除 <code>branch</code> 的操作也只会删掉这个引用，并不会删除任何的 <code>commit</code>。（不过如果一个 <code>commit</code> 不在任何一个 <code>branch</code> 的「路径」上，或者换句话说，如果没有任何一个 <code>branch</code> 可以回溯到这条 <code>commit</code>（也许可以称为野生 <code>commit</code>？），那么在一定时间后，它会被 Git 的回收机制删除掉。）</p></li><li><p>出于安全考虑，没有被合并到 <code>master</code> 过的 <code>branch</code> 在删除时会失败（因为怕你误删掉「未完成」的 <code>branch</code> 啊）：</p></li></ol><h2 id="“引用”的本质"><a href="#“引用”的本质" class="headerlink" title="“引用”的本质"></a>“引用”的本质</h2><p>所谓「引用」（reference），其实就是一个个的字符串。这个字符串可以是一个 <code>commit</code> 的 SHA-1 码（例：<code>c08de9a</code>），也可以是一个 <code>branch</code>（例：`ref: refs/heads/xxx）。</p><p>Git 中的 <code>HEAD</code> 和每一个 <code>branch</code> 以及其他的引用，都是以文本文件的形式存储在本地仓库 <code>.git</code> 目录中，而 Git 在工作的时候，就是通过这些文本文件的内容来判断这些所谓的「引用」是指向谁的。</p><h2 id="push的本质"><a href="#push的本质" class="headerlink" title="push的本质"></a>push的本质</h2><p>实质上就是本地仓库提交到远程仓库去，<code>push</code> 做的事是：把当前 <code>branch</code> 的位置（即它指向哪个 <code>commit</code>）上传到远端仓库，并把它的路径上的 <code>commit</code>s 一并上传。[提交commit在本地所有的’记录节点‘记录]</p><p><code>git push origin branch名</code></p><p><img src="https://user-gold-cdn.xitu.io/2017/11/29/1600725e9973f71d?imageslim" alt="æ master push å°è¿ç¨ä&quot;åº"></p><h2 id="feature1提交"><a href="#feature1提交" class="headerlink" title="feature1提交"></a>feature1提交</h2><p>git checkout feature1<br>git push origin feature1</p><p><img src="https://user-gold-cdn.xitu.io/2017/11/29/160073ccda56ef07?imageslim" alt="push feature1 å°è¿ç¨ä&quot;åº"></p><h2 id="merge：合并-commits"><a href="#merge：合并-commits" class="headerlink" title="merge：合并 commits"></a>merge：合并 commits</h2><p>它做的事也是合并：指定一个 <code>commit</code>，把它合并到当前的 <code>commit</code> 来</p><p>git merge branch1[在master分支下操作，意思就是把branch1分支合并到master]</p><p><img src="https://user-gold-cdn.xitu.io/2017/11/21/15fddc2aad5a0279?imageslim" alt="img"></p><p><code>merge</code> 有什么用</p><ol><li><p>合并分支</p><p>当一个 <code>branch</code> 的开发已经完成，需要把内容合并回去时，用 <code>merge</code> 来进行合并。</p></li><li><p><code>pull</code> 的内部操作</p><p>之前说过，<code>pull</code> 的实际操作其实是把远端仓库的内容用 <code>fetch</code> 取下来之后，用 <code>merge</code> 来合并。</p></li></ol><h3 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h3><ol><li>解决掉冲突</li><li>手动 <code>commit</code> 一下</li></ol><h3 id="HEAD-落后于-目标-commit——fast-forward"><a href="#HEAD-落后于-目标-commit——fast-forward" class="headerlink" title="HEAD 落后于 目标 commit——fast-forward"></a>HEAD 落后于 目标 commit——fast-forward</h3><p>git merge feature1</p><p><img src="https://user-gold-cdn.xitu.io/2017/11/21/15fddc2b2486758a?imageslim" alt="img"></p><p><img src="https://user-gold-cdn.xitu.io/2017/11/21/15fddc2b46c69d46?imageslim" alt="img"></p><h2 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h2><p>在 Git 中，有两个「偏移符号」： <code>^</code> 和 <code>~</code>。</p><p><code>^</code> 的用法：在 <code>commit</code> 的后面加一个或多个 <code>^</code> 号，可以把 <code>commit</code> 往回偏移，偏移的数量是 <code>^</code> 的数量。例如：<code>master^</code> 表示 <code>master</code> 指向的 <code>commit</code> 之前的那个 <code>commit</code>； <code>HEAD^^</code> 表示 <code>HEAD</code> 所指向的 <code>commit</code> 往前数两个 <code>commit</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~&#96; 的用法：在 &#96;commit&#96; 的后面加上 &#96;~&#96; 号和一个数，可以把 &#96;commit&#96; 往回偏移，偏移的数量是 &#96;~&#96; 号后面的数。例如：&#96;HEAD~5&#96; 表示 &#96;HEAD&#96; 指向的 &#96;commit&#96;往前数 5 个 &#96;commit</span><br></pre></td></tr></table></figure><ol><li>查看历史中的多个commit：log<ol><li>查看详细改动： <code>git log -p</code></li><li>查看大致改动：<code>git log --stat</code></li></ol></li><li>查看具体某个commit: show<ol><li>要看最新 <code>commit</code> ，直接输入 <code>git show</code> ；要看指定 <code>commit</code> ，输入 <code>git show commit的引用或SHA-1</code></li><li>如果还要指定文件，在 <code>git show</code> 的最后加上文件名</li></ol></li><li>查看未提交的内容：diff<ol><li>查看暂存区和上一条 <code>commit</code> 的区别：<code>git diff --staged</code>（或 <code>--cached</code>）</li><li>查看工作目录和暂存区的区别：<code>git diff</code> 不加选项参数</li><li>查看工作目录和上一条 <code>commit</code> 的区别：<code>git diff HEAD</code></li></ol></li></ol><h2 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h2><p>git merge branch1</p><p><img src="https://user-gold-cdn.xitu.io/2017/11/21/15fdea7b6646a1f3?imageslim" alt="img"></p><p>git checkout branch1<br>git rebase master</p><p><img src="https://user-gold-cdn.xitu.io/2017/11/30/1600abd620a8e28c?imageslim" alt="img"></p><p>commit -—amend</p><p><img src="https://user-gold-cdn.xitu.io/2017/11/21/15fdf0187f2f4b2d?imageslim" alt="img"></p><h3 id="reset-–hard-丢弃最新的提交"><a href="#reset-–hard-丢弃最新的提交" class="headerlink" title="reset –hard 丢弃最新的提交"></a>reset –hard 丢弃最新的提交</h3><p><img src="https://user-gold-cdn.xitu.io/2017/11/22/15fe19c8a6101d7f?imageslim" alt="img"></p><p>git reset –hard HEAD^</p><p><img src="https://user-gold-cdn.xitu.io/2017/11/22/15fe19c8a3235853?imageslim" alt="img"></p><p>git rebase –onto 目标 <code>commit</code>   起点 <code>commit</code>  终点 <code>commit</code></p><p>git rebase –onto 第3个commit 第4个commit branch1</p><p><img src="https://user-gold-cdn.xitu.io/2017/11/22/15fe24400d7d73d0?imageslim" alt="img"></p><h2 id="reset-的本质"><a href="#reset-的本质" class="headerlink" title="reset 的本质"></a>reset 的本质</h2><h3 id="移动-HEAD-以及它所指向的-branch"><a href="#移动-HEAD-以及它所指向的-branch" class="headerlink" title="移动 HEAD 以及它所指向的 branch"></a>移动 HEAD 以及它所指向的 branch</h3><p>git reset –hard branch2</p><p><img src="https://user-gold-cdn.xitu.io/2017/11/22/15fe333cb605b0de?imageslim" alt="img"></p><h3 id="reset-–hard-amp-reset-–soft-amp-reset-不加参数"><a href="#reset-–hard-amp-reset-–soft-amp-reset-不加参数" class="headerlink" title="reset –hard &amp; reset –soft &amp; reset 不加参数"></a>reset –hard &amp; reset –soft &amp; reset 不加参数</h3><ol><li><code>--hard</code>：重置位置的同时，清空工作目录的所有改动；</li><li><code>--soft</code>：重置位置的同时，保留工作目录和暂存区的内容，并把重置 <code>HEAD</code> 的位置所导致的新的文件差异放进暂存区。</li><li><code>--mixed</code>（默认）：重置位置的同时，保留工作目录的内容，并清空暂存区。</li></ol><h2 id="checkout-的本质"><a href="#checkout-的本质" class="headerlink" title="checkout 的本质"></a>checkout 的本质</h2><p>git checkout branch2</p><p><img src="https://user-gold-cdn.xitu.io/2017/11/30/160089d53b4f65a5?imageslim" alt="checkout"></p><p><code>git checkout branch名</code> 的本质，其实是把 <code>HEAD</code> 指向指定的 <code>branch</code>，然后签出这个 <code>branch</code> 所对应的 <code>commit</code> 的工作目录</p><h3 id="checkout-和-reset-的不同"><a href="#checkout-和-reset-的不同" class="headerlink" title="checkout 和 reset 的不同"></a>checkout 和 reset 的不同</h3><p><code>checkout</code> 和 <code>reset</code> 都可以切换 <code>HEAD</code> 的位置，它们除了有许多细节的差异外，最大的区别在于：<code>reset</code> 在移动 <code>HEAD</code> 时会带着它所指向的 <code>branch</code> 一起移动，而 <code>checkout</code> 不会</p><h3 id="stash：临时存放工作目录的改动"><a href="#stash：临时存放工作目录的改动" class="headerlink" title="stash：临时存放工作目录的改动"></a>stash：临时存放工作目录的改动</h3><p>git stash</p><p>git stash pop</p><p>git stash -u</p><h1 id="git进阶"><a href="#git进阶" class="headerlink" title="git进阶"></a>git进阶</h1><p><img src="/2020/04/04/git/git%E8%BF%9B%E9%98%B6.png" alt="git进阶.png"></p><p><img src="/2020/04/04/git/git%E5%9B%9B%E4%B8%AA%E5%8C%BA%E5%9F%9F.png" alt="git四个区域.png"></p><h2 id="git目录"><a href="#git目录" class="headerlink" title="git目录"></a>git目录</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.git&#x2F;</span><br><span class="line">    config</span><br><span class="line">    HEAD - 分支信息 </span><br><span class="line">    index - </span><br><span class="line">    objects - 保存数据对象</span><br></pre></td></tr></table></figure><h3 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;John Doe&quot; </span><br><span class="line">git config --global user.email johndoe@example.com</span><br><span class="line"></span><br><span class="line">git config --list</span><br><span class="line"></span><br><span class="line">~&#x2F;.gitconig</span><br></pre></td></tr></table></figure><p><img src="/2020/04/04/git/%E5%9B%9B%E4%B8%AA%E5%8C%BA%E5%9F%9F.png" alt="四个区域.png"></p><p><img src="/2020/04/04/git/%E5%9B%9B%E4%B8%AA%E5%8C%BA%E5%9F%9F%E6%B5%81%E7%A8%8B.png" alt="四个区域流程.png"></p><p>git 文件的状态:</p><ol><li>新建一个文件，该文件处于 <strong>Untracked</strong> 状态；</li><li>.通过<strong>git add</strong>命令添加到缓存区，此时文件处于<strong>Tracked</strong>状态又或者说 此时这个文件已经被版本控制系统所跟踪，而且他处于<strong>Staged(暂存)</strong>状态；</li><li>.通过<strong>git commit</strong>命令把暂存区的文件提交提交到本地仓库，此时文件 处于<strong>Unmodifified(未修改)</strong>状态；</li><li>此时如果去编辑这个文件，文件又会变成<strong>Modifified(修改)</strong>状态；</li></ol><h2 id="git中对象类型"><a href="#git中对象类型" class="headerlink" title="git中对象类型"></a>git中对象类型</h2><p>echo “test” | git hash-objects -w –stdin : 文本内容“test”  &gt;&gt; 哈希值</p><p>git cat-file -p 哈希值 ：哈希值 &gt; &gt;文本内容“test”</p><p>git cat-file -t 哈希值  ： 查看数据对象类型</p><p>git cat-file -p master^{tree} : 查看master分支文件信息</p><h3 id="blob对象"><a href="#blob对象" class="headerlink" title="blob对象"></a>blob对象</h3><ul><li>blob对象就是单纯存储数据</li></ul><h3 id="tree对象"><a href="#tree对象" class="headerlink" title="tree对象"></a>tree对象</h3><ul><li>像一个目录，管理一些“tree”对象或是“blob”对象</li></ul><h3 id="commit对象"><a href="#commit对象" class="headerlink" title="commit对象"></a>commit对象</h3><ul><li>“commit”对象指向一个“tree对象” </li></ul><h3 id="tag对象"><a href="#tag对象" class="headerlink" title="tag对象"></a>tag对象</h3><ul><li>一个“tag”对象包括一个对象名(SHA1签名)、对象类型、标签名、标签创建人的名字(“tagger”), 还有一条可能包含有签名(signature)的消息。</li></ul><h2 id="跟踪新文件"><a href="#跟踪新文件" class="headerlink" title="跟踪新文件"></a>跟踪新文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add README </span><br><span class="line">git status</span><br></pre></td></tr></table></figure><h2 id="暂存已修改文件"><a href="#暂存已修改文件" class="headerlink" title="暂存已修改文件"></a>暂存已修改文件</h2><h2 id="查看已暂存和未暂存的修改"><a href="#查看已暂存和未暂存的修改" class="headerlink" title="查看已暂存和未暂存的修改"></a>查看已暂存和未暂存的修改</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git diff </span><br><span class="line">git diff --staged</span><br></pre></td></tr></table></figure><h2 id="移除文件"><a href="#移除文件" class="headerlink" title="移除文件"></a>移除文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git rm </span><br><span class="line">git rm --cached</span><br></pre></td></tr></table></figure><h2 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure><p>一个常用的选项是 -p ，用来显示每次提交的内容差异。 你也可以加上 -2 来仅显示最近两次提交：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git log -p -2 </span><br><span class="line">git log --stat </span><br><span class="line">git log --pretty&#x3D;oneline </span><br><span class="line">git log --pretty&#x3D;format:&quot;%h - %an, %ar : %s&quot;</span><br></pre></td></tr></table></figure><h2 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h2><p>有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，可以运行带有 –amend 选项的提交命令尝试重新提交：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><h2 id="取消暂存的文件"><a href="#取消暂存的文件" class="headerlink" title="取消暂存的文件"></a>取消暂存的文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset</span><br></pre></td></tr></table></figure><h2 id="撤销对文件的修改"><a href="#撤销对文件的修改" class="headerlink" title="撤销对文件的修改"></a>撤销对文件的修改</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- filename</span><br></pre></td></tr></table></figure><h2 id="查看远程仓库"><a href="#查看远程仓库" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;schacon&#x2F;ticgit </span><br><span class="line">git remote -v</span><br></pre></td></tr></table></figure><h2 id="列出标签"><a href="#列出标签" class="headerlink" title="列出标签"></a>列出标签</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git tag </span><br><span class="line">git tag -l &#39;v1.8.5*&#39;</span><br></pre></td></tr></table></figure><h2 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -a v1.4 -m &#39;my version 1.4&#39;</span><br></pre></td></tr></table></figure><h2 id="本地分支"><a href="#本地分支" class="headerlink" title="本地分支"></a>本地分支</h2><h3 id="分支的概念"><a href="#分支的概念" class="headerlink" title="分支的概念"></a>分支的概念</h3><p>提交记录串成的时间线，默认初始创建的分支(时间线) —— <strong>master</strong>分支， 如果不切换到其他分支上，每次commit生成的快照都会串在这条分支上！ 另外还有个 —— <strong>HEAD</strong>指针，该指针指向<strong>正在工作的本地分支</strong>，前面的版本回退其实修改的就是这个<strong>HEAD指针的指向</strong>！</p><h3 id="分支简介"><a href="#分支简介" class="headerlink" title="分支简介"></a>分支简介</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add README test.rb LICENSE </span><br><span class="line">git commit -m &#39;The initial commit of my project&#39;</span><br></pre></td></tr></table></figure><h3 id="新建分支"><a href="#新建分支" class="headerlink" title="新建分支"></a>新建分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b iss53 </span><br><span class="line">git branch iss53 </span><br><span class="line">git checkout iss53</span><br><span class="line">git merge</span><br><span class="line">git rebase</span><br><span class="line">git reset 与 git checkout 差异</span><br></pre></td></tr></table></figure><h2 id="git-flow"><a href="#git-flow" class="headerlink" title="git flow"></a>git flow</h2><p><img src="/2020/04/04/git/git_flow.png" alt="git_flow.png"></p><h3 id="gitflow流程常用分支"><a href="#gitflow流程常用分支" class="headerlink" title="gitflow流程常用分支"></a>gitflow流程常用分支</h3><h4 id="Production-分支-master"><a href="#Production-分支-master" class="headerlink" title="Production 分支[master]"></a><strong>Production</strong> 分支[master]</h4><p>也就是我们经常使用的Master分支，这个分支最近发布到生产环境的代码，最近发布的Release， 这个分支只能从其他分支合并，不能在这个分支直接修改</p><h4 id="Develop-分支"><a href="#Develop-分支" class="headerlink" title="Develop 分支"></a><strong>Develop</strong> 分支</h4><p>这个分支是我们是我们的主开发分支，包含所有要发布到下一个Release的代码，这个主要合并与其他分支，比如Feature分支</p><h4 id="Feature-分支"><a href="#Feature-分支" class="headerlink" title="Feature 分支"></a><strong>Feature</strong> <strong>分支</strong></h4><p>这个分支主要是用来开发一个新的功能，一旦开发完成，我们合并回Develop分支进入下一个Release</p><h4 id="Release分支"><a href="#Release分支" class="headerlink" title="Release分支"></a>Release分支</h4><p>当你需要一个发布一个新Release的时候，我们基于Develop分支创建一个Release分支，完成Release后，我们合并到Master和Develop分支</p><h4 id="Hotfifix分支"><a href="#Hotfifix分支" class="headerlink" title="Hotfifix分支"></a>Hotfifix分支</h4><p>当我们在Production发现新的Bug时候，我们需要创建一个Hotfifix, 完成Hotfifix后，我们合并回Master和Develop分支，所以Hotfifix的改动会进入下一个Release</p><h2 id="分支命名规范"><a href="#分支命名规范" class="headerlink" title="分支命名规范"></a>分支命名规范</h2><h3 id="开发阶段"><a href="#开发阶段" class="headerlink" title="开发阶段"></a>开发阶段</h3><p>开发新需求都从master拉取feature分支，不同迭代发布代码使用不同的分支，避免相互影响。</p><p>需要进行开发环境联调的代码合并到develop分支，由jenkins自动发布到开发环境。</p><p>命名方式：dev-mmdd(时间)-需求名称，例如：dev-1205-xxxx</p><h3 id="测试阶段"><a href="#测试阶段" class="headerlink" title="测试阶段"></a>测试阶段</h3><p>每月为一个迭代周期由系统owner拉取提测分支test，并定期维护(merge master)。</p><p>开发feature分支合并到提测test分支，合并前需要由模块负责人进行review或交叉review。</p><p>多个feature分支在测试过程中，需要借助release分支来进行合并，然后再进行提测。</p><p>多个feature分支在测试过程中，某一个需求不能如期发布，需要将release分支删除，将可继续的分支重复执行第2步进行测试验证；</p><p>命名方式：test-mmdd(每月10日)，例如：test-1215 / release-mmdd(每月10日)，例如：release-1210</p><h3 id="发布阶段"><a href="#发布阶段" class="headerlink" title="发布阶段"></a>发布阶段</h3><p>测试通过后release进行merge master，并解决冲突，在release分支回归测试</p><p>回归通过后，先在master分支拉取tag分支备份，然后把release合并到master。</p><p>发布master</p><p>命名方式：tag-mmdd(时间)，例如：tag-1212</p><h4 id="git-flow-代码示例"><a href="#git-flow-代码示例" class="headerlink" title="git flow 代码示例"></a>git flow 代码示例</h4><p>a. 创建develop分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch develop </span><br><span class="line">git push -u origin develop</span><br></pre></td></tr></table></figure><p>b.开始新Feature开发</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b some-feature develop # Optionally, push branch to origin: git push -u origin some-feature </span><br><span class="line"># 做一些改动 </span><br><span class="line">git status </span><br><span class="line">git add some-file </span><br><span class="line">git commit</span><br></pre></td></tr></table></figure><p>c. 完成Feature</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git pull origin develop </span><br><span class="line">git checkout develop </span><br><span class="line">git merge --no-ff some-feature </span><br><span class="line">git push origin develop </span><br><span class="line">git branch -d some-feature </span><br><span class="line"># If you pushed branch to origin: git push origin --delete some-feature</span><br></pre></td></tr></table></figure><p>d.开始Relase</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b release-0.1.0 develop </span><br><span class="line"># Optional: Bump version number, commit </span><br><span class="line"># Prepare release, commit</span><br></pre></td></tr></table></figure><p>e. 完成Release</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">git checkout master </span><br><span class="line">git merge --no-ff release-0.1.0 </span><br><span class="line">git push </span><br><span class="line"></span><br><span class="line">git checkout develop </span><br><span class="line">git merge --no-ff release-0.1.0 </span><br><span class="line">git push </span><br><span class="line"></span><br><span class="line">git branch -d release-0.1.0 </span><br><span class="line"></span><br><span class="line"># If you pushed branch to origin: </span><br><span class="line">git push origin --delete release-0.1.0 </span><br><span class="line"></span><br><span class="line">git tag -a v0.1.0 master </span><br><span class="line">git push --tags</span><br></pre></td></tr></table></figure><p>f.开始Hotfifix</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b hotfix-0.1.1 master</span><br></pre></td></tr></table></figure><p>g.完成Hotfifix</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">git checkout master </span><br><span class="line">git merge --no-ff hotfix-0.1.1 </span><br><span class="line">git push </span><br><span class="line"></span><br><span class="line">git checkout develop </span><br><span class="line">git merge --no-ff hotfix-0.1.1 </span><br><span class="line">git push </span><br><span class="line"></span><br><span class="line">git branch -d hotfix-0.1.1 </span><br><span class="line"></span><br><span class="line">git tag -a v0.1.1 master </span><br><span class="line">git push --tags</span><br></pre></td></tr></table></figure><h1 id="实际操作-常用命令及详用示例"><a href="#实际操作-常用命令及详用示例" class="headerlink" title="实际操作-常用命令及详用示例"></a>实际操作-常用命令及详用示例</h1><p>git help</p><h2 id="233"><a href="#233" class="headerlink" title="233"></a>233</h2>]]></content>
      
      
      <categories>
          
          <category> 版本控制版本：db2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>db2</title>
      <link href="/2020/04/04/db2/"/>
      <url>/2020/04/04/db2/</url>
      
        <content type="html"><![CDATA[<p>数据库：db2</p><a id="more"></a><h1 id="DB2简介"><a href="#DB2简介" class="headerlink" title="DB2简介"></a>DB2简介</h1><ul><li><p>IBM公司的数据库系统</p></li><li><p>关系型数据库系统</p></li><li><p>适用于大型应用系统，如：某企业门户网站，商务智能系统.</p></li><li><p>支持大多数主流操作系统，如：Windows,Linux,AIX.</p></li><li><p>与平台无关的基本功能和SQL语句.</p><blockquote><p>补充知识：IBM的主机体系简介</p><p>System Zero(大型机)，System Performance(小型机)，System Integrated.</p></blockquote></li></ul><h1 id="DB2支持的平台及版本"><a href="#DB2支持的平台及版本" class="headerlink" title="DB2支持的平台及版本"></a>DB2支持的平台及版本</h1><h2 id="支持的平台"><a href="#支持的平台" class="headerlink" title="支持的平台"></a>支持的平台</h2><p><img src="/2020/04/04/db2/%E6%94%AF%E6%8C%81%E7%9A%84%E5%B9%B3%E5%8F%B0.png" alt="支持的平台"></p><h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><p><img src="/2020/04/04/db2/%E7%89%88%E6%9C%AC.png" alt="版本"></p><h1 id="DB2主要的产品组件及功能"><a href="#DB2主要的产品组件及功能" class="headerlink" title="DB2主要的产品组件及功能"></a>DB2主要的产品组件及功能</h1><p><img src="/2020/04/04/db2/DB2_Connect.png" alt="DB2_Connect"></p><p>DB2 Connect Application Server Advanced Editon (DB2 Connect 应用服务器高级版)</p><p>DB2 Connect Application Server Edition(DB2 Connect 应用服务器版)</p><p>DB2 Connect Enterprise Editon (DB2 Connect 企业版)</p><h1 id="DB2体系结构简介"><a href="#DB2体系结构简介" class="headerlink" title="DB2体系结构简介"></a>DB2体系结构简介</h1><h2 id="DB2体系结构简图"><a href="#DB2体系结构简图" class="headerlink" title="DB2体系结构简图"></a>DB2体系结构简图</h2><p><img src="/2020/04/04/db2/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AE%80%E5%9B%BE.png" alt="体系结构简图"></p><ol><li>一个数据库实例可以管理一到多个数据库。实例&gt;数据库</li><li>数据库由一到多个表空间组成。数据库&gt;表空间</li><li>表存储在表空间中。表空间&gt;表</li></ol><h2 id="数据库管理实例"><a href="#数据库管理实例" class="headerlink" title="数据库管理实例"></a>数据库管理实例</h2><p><img src="/2020/04/04/db2/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E5%AE%9E%E4%BE%8B.png" alt="数据库管理实例"></p><ol><li><p>不同版本的DB2产品可以共存于同一套操作系统。一个操作系统可以安装多个DB2。</p></li><li><p>每个DB2产品可以创建一到多个实例。一个DB2可以创建多个实例。</p></li><li><p>每个数据库实例都有自己的配置文件。每个实例自定义配置自己的配置文件。</p><p><strong>实例：逻辑意义上存在的概念，只有配置文件，不占用物理内存。</strong></p></li></ol><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p><img src="/2020/04/04/db2/%E6%95%B0%E6%8D%AE%E5%BA%93.png" alt="数据库"></p><ol><li>数据库必须受实例的管理。</li><li>在<strong>非集群</strong>的情况下，一个数据库只能受一个实例的管理。</li><li>每个数据库都有自己的配置文件。</li></ol><h2 id="表空间"><a href="#表空间" class="headerlink" title="表空间"></a>表空间</h2><p><img src="/2020/04/04/db2/%E6%95%B0%E6%8D%AE%E5%BA%93.png" alt="表空间"></p><ol><li>数据库由一到多个表空间组成。</li><li>表空间用于存储<strong>数据库对象</strong>，比如：表，索引等。</li></ol><h2 id="表"><a href="#表" class="headerlink" title="表"></a>表</h2><p><img src="/2020/04/04/db2/%E6%95%B0%E6%8D%AE%E5%BA%93.png" alt="表"></p><ol><li>表用于存储用户数据。</li><li>表位于表空间中。</li></ol><h2 id="示例—查看各组件"><a href="#示例—查看各组件" class="headerlink" title="示例—查看各组件"></a>示例—查看各组件</h2><ol><li>查看实例</li><li>查看数据库</li><li>查看表空间</li></ol><ul><li>root用户切换到db2实例用户：su - db2inst1[实例用户名称]</li><li>查看数据库版本：db2level</li></ul><p><img src="/2020/04/04/db2/root%E7%94%A8%E6%88%B7%E5%88%87%E6%8D%A2%E5%88%B0db2%E6%95%B0%E6%8D%AE%E5%BA%93.png" alt="root用户切换到db2实例"></p><ul><li>查看数据产品创建有多少个实例：db2ilist</li></ul><p><img src="/2020/04/04/db2/%E6%9F%A5%E7%9C%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E4%BE%8B.png" alt="查看数据库实例"></p><ul><li>查看当前数据库实例管理哪些数据库：db2 list db directory</li></ul><p><img src="/2020/04/04/db2/%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E4%BE%8B%E7%AE%A1%E7%90%86%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E5%BA%93.png" alt="查看当前数据库实例管理哪些数据库"></p><ul><li>数据库信息[sample]</li></ul><p><img src="/2020/04/04/db2/%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E4%BE%8B%E7%AE%A1%E7%90%86%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E5%BA%932.png" alt="查看当前数据库实例管理哪些数据库2"></p><ul><li>连接数据库：db2 connect to sample</li></ul><p><img src="/2020/04/04/db2/%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93.png" alt="连接数据库"></p><ul><li>查看数据库创建有多少个实例：db2 list tablespaces</li></ul><p><img src="/2020/04/04/db2/%E6%9F%A5%E7%9C%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%9B%E5%BB%BA%E6%9C%89%E5%A4%9A%E5%B0%91%E4%B8%AA%E5%AE%9E%E4%BE%8B.png" alt="查看数据库创建有多少个表空间"></p><ul><li>表空间信息</li></ul><p><img src="/2020/04/04/db2/%E8%A1%A8%E7%A9%BA%E9%97%B4%E4%BF%A1%E6%81%AF.png" alt="表空间信息"></p><h1 id="DB2实例与管理服务器"><a href="#DB2实例与管理服务器" class="headerlink" title="DB2实例与管理服务器"></a>DB2实例与管理服务器</h1><h2 id="理解实例"><a href="#理解实例" class="headerlink" title="理解实例"></a>理解实例</h2><h3 id="实例的概念"><a href="#实例的概念" class="headerlink" title="实例的概念"></a>实例的概念</h3><p><img src="/2020/04/04/db2/%E5%AE%9E%E4%BE%8B.png" alt="实例.png"></p><ul><li>实例为数据库提供了运行时环境。</li><li>实例是由一组后台进程和共享内存组成的。</li><li>数据库是物理的，而实例是逻辑的。</li></ul><h3 id="创建几个实例合适"><a href="#创建几个实例合适" class="headerlink" title="创建几个实例合适"></a>创建几个实例合适</h3><p><img src="/2020/04/04/db2/DB2%E4%BA%A7%E5%93%81.png" alt="DB2产品.png"></p><ul><li>一个DB2产品可以创建多个实例。</li><li>每个实例都有自己的配置文件。</li><li>每个实例都有自己独立的共享内存和进程结构</li><li>实际生产系统中，实例的个数选择要适情况而定。</li></ul><h2 id="管理实例"><a href="#管理实例" class="headerlink" title="管理实例"></a>管理实例</h2><h3 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h3><h4 id="实例与操作系统用户的关系"><a href="#实例与操作系统用户的关系" class="headerlink" title="实例与操作系统用户的关系"></a>实例与操作系统用户的关系</h4><ul><li><p>Windows:不需要创建用户，默认实例名为DB2.</p></li><li><p>Linux&amp;Unix:实例名与用户名一样</p><p><strong>注意：确保用户状态正常</strong></p></li></ul><h4 id="创建实例的语法—Linux-amp-Unix"><a href="#创建实例的语法—Linux-amp-Unix" class="headerlink" title="创建实例的语法—Linux&amp;Unix"></a>创建实例的语法—Linux&amp;Unix</h4><p><img src="/2020/04/04/db2/%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B%E7%9A%84%E8%AF%AD%E6%B3%95Linux&Unix.png" alt="创建实例的语法Linux&amp;Unix.png"></p><h4 id="创建实例的语法—Windows"><a href="#创建实例的语法—Windows" class="headerlink" title="创建实例的语法—Windows"></a>创建实例的语法—Windows</h4><p><img src="/2020/04/04/db2/%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B%E7%9A%84%E8%AF%AD%E6%B3%95Windows.png" alt="创建实例的语法Windows.png"></p><h4 id="创建实例示例"><a href="#创建实例示例" class="headerlink" title="创建实例示例"></a>创建实例示例</h4><ul><li><p>Linux&amp;Unix 上创建实例：</p><p>DB2DIR/instance/db2icrt -u FencedID InstName</p></li><li><p>Windows 上创建实例：</p><p>DB2DIR\bin\db2icrt InstName</p></li></ul><p><img src="/2020/04/04/db2/%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B.png" alt="创建实例.png"></p><h3 id="启动实例"><a href="#启动实例" class="headerlink" title="启动实例"></a>启动实例</h3><ul><li>启动实例：连接数据库、编译应用程序、绑定程序包等</li><li>启动实例必须具有相应的权限</li><li>启动实例的命令： db2start</li></ul><p><img src="/2020/04/04/db2/%E5%90%AF%E5%8A%A8%E5%AE%9E%E4%BE%8B.png" alt="启动实例.png"></p><h3 id="连接和断开实例"><a href="#连接和断开实例" class="headerlink" title="连接和断开实例"></a>连接和断开实例</h3><ul><li>连接实例的命令：db2 attach to INSTName</li><li>断开实例的命令：db2 detach</li></ul><p><img src="/2020/04/04/db2/%E8%BF%9E%E6%8E%A5%E5%92%8C%E6%96%AD%E5%BC%80%E5%AE%9E%E4%BE%8B.png" alt="连接和断开实例.png"></p><h3 id="停止实例"><a href="#停止实例" class="headerlink" title="停止实例"></a>停止实例</h3><ul><li>停止实例必须具有相应的权限</li><li>停止实例的命令： db2stop</li><li>强制应用程序与用户与数据库断开：db2stop force</li></ul><p><img src="/2020/04/04/db2/%E5%81%9C%E6%AD%A2%E5%AE%9E%E4%BE%8B.png" alt="停止实例.png"></p><h3 id="实例参数"><a href="#实例参数" class="headerlink" title="实例参数"></a>实例参数</h3><ul><li>查看实例参数： db2 get dbm cfg</li><li>修改实例参数： db2 update dbm cfg using 参数名 参数值</li><li>复位实例参数为默认值： db2 reset dbm cfg</li></ul><p><img src="/2020/04/04/db2/%E5%AE%9E%E4%BE%8B%E5%8F%82%E6%95%B0.png" alt="实例参数.png"></p><h3 id="删除实例"><a href="#删除实例" class="headerlink" title="删除实例"></a>删除实例</h3><ul><li>删除实例，必须具有root或者系统管理员权限</li><li>删除实例前，要确保实例已经停止</li><li>删除实例的命令： db2idrop</li></ul><p><img src="/2020/04/04/db2/%E5%88%A0%E9%99%A4%E5%AE%9E%E4%BE%8B.png" alt="删除实例.png"></p><h3 id="操作实例的其他命令"><a href="#操作实例的其他命令" class="headerlink" title="操作实例的其他命令"></a>操作实例的其他命令</h3><ul><li>查看实例：db2ilist</li><li>更新实例：db2iupdt</li><li>迁移实例：db2imigr</li><li>自动启动实例：db2iauto</li></ul><h2 id="DB2的环境变量"><a href="#DB2的环境变量" class="headerlink" title="DB2的环境变量"></a>DB2的环境变量</h2><h3 id="环境变量的优先级"><a href="#环境变量的优先级" class="headerlink" title="环境变量的优先级"></a>环境变量的优先级</h3><p><img src="/2020/04/04/db2/%E4%BC%98%E5%85%88%E7%BA%A7.png" alt="优先级.png"></p><ul><li><p>操作系统级别的环境变量</p><p>–使用set 或者 export设置</p></li><li><p>全局级概要文件注册变量</p><p>–使用db2set -g 设置</p></li><li><p>实例级概要文件注册变量</p><p>–使用db2set -i 设置</p></li><li><p>实例节点级概要文件注册变量</p><p>–使用 db2set -i <instance name><nodenum>命令</nodenum></instance></p></li></ul><h3 id="管理实例注册变量"><a href="#管理实例注册变量" class="headerlink" title="管理实例注册变量"></a>管理实例注册变量</h3><p><img src="/2020/04/04/db2/%E7%AE%A1%E7%90%86%E5%AE%9E%E4%BE%8B%E6%B3%A8%E5%86%8C%E5%8F%98%E9%87%8F.png" alt="管理实例注册变量.png"></p><ul><li>管理实例变量的命令：db2set</li><li>查看已经设置的实例变量：db2set -all</li><li>查看所有可进行定义的实例变量：db2set -lr</li></ul><h2 id="实例目录"><a href="#实例目录" class="headerlink" title="实例目录"></a>实例目录</h2><h3 id="概念与作用"><a href="#概念与作用" class="headerlink" title="概念与作用"></a>概念与作用</h3><p><img src="/2020/04/04/db2/%E5%AE%9E%E4%BE%8B%E7%9B%AE%E5%BD%95_%E6%A6%82%E5%BF%B5%E4%B8%8E%E4%BD%9C%E7%94%A8.png" alt="实例目录_概念与作用.png"></p><ul><li>存储于数据库实例相关的所有信息</li><li>实例创建后，自动生成实例目录</li><li>在Linux或Unix上，实例目录位于User_home/sqllib目录中</li><li>在Windos上，实例目录位于db2数据库产品的sqllib目录中</li></ul><h3 id="实例目录的内容"><a href="#实例目录的内容" class="headerlink" title="实例目录的内容"></a>实例目录的内容</h3><p><img src="/2020/04/04/db2/%E5%AE%9E%E4%BE%8B%E7%9B%AE%E5%BD%95%E7%9A%84%E5%86%85%E5%AE%B9.png" alt="实例目录的内容"></p><h2 id="管理服务器"><a href="#管理服务器" class="headerlink" title="管理服务器"></a>管理服务器</h2><h3 id="概念与作用-1"><a href="#概念与作用-1" class="headerlink" title="概念与作用"></a>概念与作用</h3><p><img src="/2020/04/04/db2/DAS.png" alt="DAS.png"></p><ul><li>数据库管理服务器DAS(Database Administration Server)是一个特殊的数据库实例</li><li>用于执行远程的DB2数据库管理任务</li><li>DAS和受管实例是一对多的关系，即一个DAS可以管理多个实例</li></ul><h3 id="管理命令"><a href="#管理命令" class="headerlink" title="管理命令"></a>管理命令</h3><ul><li>用于启动DAS: db2admin start </li><li>用于终止DAS: db2admin stop</li><li>在Linux&amp;Unix环境下创建DAS: dasicrt</li><li>在Linux&amp;Unix环境下删除DAS: dasidrop</li><li>在Windows环境下创建DAS: db2admin create</li><li>在Windows环境下删除DAS: db2admin drop</li><li>用于显示DAS的数据库管理器配置：db2 get admin cfg</li><li>用于更改DAS的数据库管理器配置文件的参数：db2 update admin cfg</li><li>用于将DAS的配置参数设置为默认值：db2 reset admin cfg</li></ul><h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><ol><li><p>查看db2icrt 和 db2idrop 所在的路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;opt&#x2F;ibm&#x2F;db2&#x2F;V10.5</span><br></pre></td></tr></table></figure></li><li><p>检查是否创建了受防护的用户和实例用户，并且设置密码</p></li><li><p>在创建实例前，查看home路径下是否有sqllib</p></li><li><p>创建实例</p></li><li><p>检查sqllib目录是否创建成功</p></li><li><p>启动实例：db2start</p></li><li><p>连接到实例：db2 attach to db2inst1</p></li><li><p>从实例中断开： db2detach</p></li><li><p>停止实例： db2stop</p></li><li><p>启动实例并且创建一个测试数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db2 start</span><br><span class="line">db2 create db test</span><br></pre></td></tr></table></figure></li><li><p>额外用一个用户连接实例，再停止实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db2 connect to test</span><br><span class="line">db2stop</span><br><span class="line">db2 stop force</span><br></pre></td></tr></table></figure></li><li><p>查看实例的参数： db2 get dbm cfg</p></li><li><p>修改参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db2 update dbm cfg using ASLHEAPSZ 20</span><br></pre></td></tr></table></figure></li><li><p>删除实例： db2idrop db2inst1</p></li><li><p>检查sqllib目录是否还存在</p></li></ol><h1 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h1><h2 id="建库前的准备"><a href="#建库前的准备" class="headerlink" title="建库前的准备"></a>建库前的准备</h2><h3 id="数据库、表空间、表的关系"><a href="#数据库、表空间、表的关系" class="headerlink" title="数据库、表空间、表的关系"></a>数据库、表空间、表的关系</h3><p><img src="/2020/04/04/db2/%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%81%E8%A1%A8%E7%A9%BA%E9%97%B4%E3%80%81%E8%A1%A8%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="数据库、表空间、表的关系.png"></p><ul><li>数据库由实例进行创建和管理</li><li>数据库包含一到多个表空间</li><li>表存储在表空间</li></ul><h3 id="表空间、容器、区与数据页"><a href="#表空间、容器、区与数据页" class="headerlink" title="表空间、容器、区与数据页"></a>表空间、容器、区与数据页</h3><p><img src="/2020/04/04/db2/%E8%A1%A8%E7%A9%BA%E9%97%B4%E3%80%81%E5%AE%B9%E5%99%A8%E3%80%81%E5%8C%BA%E4%B8%8E%E6%95%B0%E6%8D%AE%E9%A1%B5.png" alt="表空间、容器、区与数据页.png"></p><ul><li>表空间有一到多个容器组成</li><li>表空间容器（Container）是由多个区组成的</li><li>区(extent)有整体倍的数据页组成</li><li>数据库的最小存储单位是数据页（datapage）</li></ul><h3 id="容器与表空间"><a href="#容器与表空间" class="headerlink" title="容器与表空间"></a>容器与表空间</h3><p><img src="/2020/04/04/db2/%E5%AE%B9%E5%99%A8%E4%B8%8E%E8%A1%A8%E7%A9%BA%E9%97%B4.png" alt="容器与表空间.png"></p><ul><li>表、索引等逻辑对象放在表空间</li><li>容器是位于底层的物理存储</li><li>表空间是数据库物理存储于逻辑存储的统一</li><li>容器可以是目录、文件或者设备</li></ul><h2 id="使用命令行创建数据库"><a href="#使用命令行创建数据库" class="headerlink" title="使用命令行创建数据库"></a>使用命令行创建数据库</h2><h3 id="创建数据库的语法"><a href="#创建数据库的语法" class="headerlink" title="创建数据库的语法"></a>创建数据库的语法</h3><p><img src="/2020/04/04/db2/%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%AF%AD%E6%B3%95.png" alt="创建数据库的语法"></p><h3 id="数据库的名称和分区"><a href="#数据库的名称和分区" class="headerlink" title="数据库的名称和分区"></a>数据库的名称和分区</h3><p><img src="/2020/04/04/db2/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%90%8D%E7%A7%B0%E5%92%8C%E5%88%86%E5%8C%BA.png" alt="数据库的名称和分区"></p><ul><li>database-name 指定数据库的名称</li><li>AT DBPARTIONNUM 用于指定在哪个数据库的分区恢复数据库</li><li>最简单的建库命令： create database database_name</li></ul><h3 id="数据库和自动存储的位置（1）"><a href="#数据库和自动存储的位置（1）" class="headerlink" title="数据库和自动存储的位置（1）"></a>数据库和自动存储的位置（1）</h3><p><img src="/2020/04/04/db2/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%87%AA%E5%8A%A8%E5%AD%98%E5%82%A8%E7%9A%84%E4%BD%8D%E7%BD%AE1_1.png" alt="数据库和自动存储的位置1_1.png"></p><p><img src="/2020/04/04/db2/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%87%AA%E5%8A%A8%E5%AD%98%E5%82%A8%E7%9A%84%E4%BD%8D%E7%BD%AE1_2.png" alt="数据库和自动存储的位置1_2.png"></p><h3 id="数据库和自动存储的位置（2）"><a href="#数据库和自动存储的位置（2）" class="headerlink" title="数据库和自动存储的位置（2）"></a>数据库和自动存储的位置（2）</h3><ul><li><p>create database jikedb1 on /jikedb1</p><p>—数据库路径： /jikedb1</p><p>—自动存储路径： /jikedb1</p></li><li><p>create database jikedb2 automatic storage no on /jikedb2</p><p>—数据库路径： /jikedb2</p><p>—未使用自动存储特性</p></li><li><p>create database jikedb3 on /jikedbauto3 dbpath on /jikedb3</p><p>—数据库路径： /jikedb3</p><p>—自动存储路径： /jikedbauto3</p></li><li><p>create database jikedb4  automatic storage yes on</p><p>/jikedbauto41,/jikedbauto42,/jikedbauto43 dbpath on /jikedb4</p><p>—数据库路径： /jikedb4</p><p>—自动存储路径： /jikedbauto41,/jikedbauto42,/jikedbauto43</p></li></ul><h3 id="别名、代码页和整理次序"><a href="#别名、代码页和整理次序" class="headerlink" title="别名、代码页和整理次序"></a>别名、代码页和整理次序</h3><p><img src="/2020/04/04/db2/%E5%88%AB%E5%90%8D%E3%80%81%E4%BB%A3%E7%A0%81%E9%A1%B5%E5%92%8C%E6%95%B4%E7%90%86%E6%AC%A1%E5%BA%8F.png" alt="别名、代码页和整理次序.png"></p><ul><li>ALIAS db-alias为数据库指定别名</li><li>CODESET(字符集)和TERRITORY(地域)用于指定代码页</li><li>COLLATE指定数据库的整理次序</li></ul><h3 id="数据页与默认区的大小"><a href="#数据页与默认区的大小" class="headerlink" title="数据页与默认区的大小"></a>数据页与默认区的大小</h3><p><img src="/2020/04/04/db2/%E6%95%B0%E6%8D%AE%E9%A1%B5%E4%B8%8E%E9%BB%98%E8%AE%A4%E5%8C%BA%E7%9A%84%E5%A4%A7%E5%B0%8F.png" alt="数据页与默认区的大小.png"></p><ul><li>PAGESIZE 指定数据库的表空间和缓冲池所使用的默认数据页大小</li><li>DFT_EXTENT_SZ 指定数据库的表空间默认使用的区的大小</li></ul><h3 id="默认的表空间"><a href="#默认的表空间" class="headerlink" title="默认的表空间"></a>默认的表空间</h3><p><img src="/2020/04/04/db2/%E9%BB%98%E8%AE%A4%E7%9A%84%E8%A1%A8%E7%A9%BA%E9%97%B4.png" alt="默认的表空间.png"></p><ul><li>SYSCATSPACE:用CATALOG TABLESPACE指定，存储DB2系统编目，即“数据字典”</li><li>TEMPSPACE1:用TEMPORARY TABLESPACE指定，是DB2放置分组、排序、连接和重组等操作中间结果集的临时存储区域</li><li>USERSPACE1:用USER TABLESPACE指定，默认情况下存储所有用户对象的表空间</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">注意：</span><br><span class="line">   1.要用实例用户登录；</span><br><span class="line">   2.记得创建相应的目录；</span><br><span class="line">   3.目录要改为实例的权限。</span><br><span class="line">查看是否创建成功：</span><br><span class="line">   db2 list db directory</span><br></pre></td></tr></table></figure><h2 id="使用向导创建数据库"><a href="#使用向导创建数据库" class="headerlink" title="使用向导创建数据库"></a>使用向导创建数据库</h2><h2 id="数据库的目录"><a href="#数据库的目录" class="headerlink" title="数据库的目录"></a>数据库的目录</h2><h3 id="数据库的目录-1"><a href="#数据库的目录-1" class="headerlink" title="数据库的目录"></a>数据库的目录</h3><ul><li><p>数据库目录用于存储数据库的信息：如表空间、表、容器等信息</p></li><li><p>创建位置取决于创建数据库时指定的数据库路径</p></li><li><p>分区全局目录结构：db_path/instance_name/NODE0000/SQL00001</p><p>—db_path:创建数据库时指定的路径</p><p>—instance_name:与实例名相同的子目录</p><p>—NODE0000:用于区分多分区数据库的逻辑分区</p><p>—SQL00001:包含第一个数据库以及随后所创建数据库相关联的对象</p></li><li><p>特定成员目录：MEMBER0000</p></li></ul><h3 id="分区全局目录"><a href="#分区全局目录" class="headerlink" title="分区全局目录"></a>分区全局目录</h3><p><img src="/2020/04/04/db2/%E5%88%86%E5%8C%BA%E5%85%A8%E5%B1%80%E7%9B%AE%E5%BD%95.png" alt="分区全局目录.png"></p><ul><li><p>表空间信息文件</p><p>—SQLSPCS.1和SQLSPCS.2</p></li><li><p>存储器组控制文件</p><p>—SQLSGF.1和SQLSGF.2</p></li><li><p>全局配置文件</p><p>—SQLDBCONF</p></li><li><p>历史记录文件</p><p>—DB2RHIST.ASC和DB2RHIST.BAK</p></li><li><p>与日志记录相关的文件</p><p>—SQLOGCTL.GLFH.1和SQLOGCTL.GLFH.2</p></li><li><p>锁定文件</p><p>—SQLINSLK和SQLTMPLK</p></li></ul><h3 id="特定成员目录"><a href="#特定成员目录" class="headerlink" title="特定成员目录"></a>特定成员目录</h3><p><img src="/2020/04/04/db2/%E7%89%B9%E5%AE%9A%E6%88%90%E5%91%98%E7%9B%AE%E5%BD%95.png" alt="特定成员目录.png"></p><ul><li><p>缓冲池信息文件</p><p>—SQLBP.1和SQLBP.2</p></li><li><p>本地事件监视器文件</p></li><li><p>与日志记录相关的文件</p><p>—SQLOGCTL.LFH.1</p><p>—SQLOGCTL.LFH.2</p><p>—SQLOGCTL.LFH</p></li><li><p>本地配置文件</p><p>—SQLDBCONF</p></li></ul><h1 id="DB2表空间的管理"><a href="#DB2表空间的管理" class="headerlink" title="DB2表空间的管理"></a>DB2表空间的管理</h1><h2 id="了解表空间"><a href="#了解表空间" class="headerlink" title="了解表空间"></a>了解表空间</h2><h3 id="表空间的作用"><a href="#表空间的作用" class="headerlink" title="表空间的作用"></a>表空间的作用</h3><p><img src="/2020/04/04/db2/%E8%A1%A8%E7%A9%BA%E9%97%B4%E7%9A%84%E4%BD%9C%E7%94%A8.png" alt="表空间的作用.png"></p><ul><li>表空间是用户逻辑对象的存储空间</li><li>表空间在物理层上对应若干个容器</li><li>容器可以是目录、文件或者裸设备</li><li>表空间是逻辑层与物理层的桥梁</li><li>数据库可以有多个表空间，表空间可以有多个容器</li></ul><h3 id="表空间的类型"><a href="#表空间的类型" class="headerlink" title="表空间的类型"></a>表空间的类型</h3><ul><li><p>目录表空间：</p><p>—存储DB2系统编目，即“数据字典”</p><p>—默认名称：syscatspace</p></li><li><p>系统临时表空间</p><p>—用于存储分组、排序、连接、重组、创建索引等操作的中间结果</p><p>—数据库至少有一个这样的表空间</p><p>—默认创建的名称：tempspace1</p></li><li><p>用户临时表空间：</p><p>—默认不会创建</p><p>—存放使用DECLARE GLOBAL TEMPORARY TABLE </p><p>​    或 CREATE GLOBAL TEMPORARY TABLE 语句创建的表的临时数据</p></li><li><p>用户表空间</p><p>—存储用户对象（表、索引等）的空间</p><p>—默认创建的名称：userspace1</p></li></ul><h3 id="表空间的存储的类型"><a href="#表空间的存储的类型" class="headerlink" title="表空间的存储的类型"></a>表空间的存储的类型</h3><ul><li>数据库支持三种存储类型的表空间</li><li>系统管理的表空间（System-Managed Space,SMS）</li><li>数据库管理的表空间（Database-Managed Space,DMS）</li><li>自动存储的表空间（Automatic Storage With DMS）</li><li>三种存储的表空间可以共存于同一个数据库</li></ul><h3 id="SMS表空间"><a href="#SMS表空间" class="headerlink" title="SMS表空间"></a>SMS表空间</h3><p><img src="/2020/04/04/db2/SMS%E8%A1%A8%E7%A9%BA%E9%97%B4.png" alt="SMS表空间.png"></p><ul><li>表空间的容器是操作系统的目录或者文件夹</li><li>空间的分配和管理由操作系统的文件系统来完成</li><li>提供的优化选项比较少且性能不好</li></ul><h3 id="DMS表空间"><a href="#DMS表空间" class="headerlink" title="DMS表空间"></a>DMS表空间</h3><p><img src="/2020/04/04/db2/DMS%E8%A1%A8%E7%A9%BA%E9%97%B4.png" alt="DMS表空间"></p><ul><li>表空间容器可以使用文件或者裸设备</li><li>存储空间的分配和管理由数据库来完成</li><li>DMS表空间可以被定义为大型（缺省）或常规表空间</li></ul><h3 id="自动存储管理的表空间"><a href="#自动存储管理的表空间" class="headerlink" title="自动存储管理的表空间"></a>自动存储管理的表空间</h3><ul><li>数据库管理器负责创建和扩展容器</li><li>将存储的管理由表空间层面转入数据库层面</li><li>简化了表空间存储的管理</li></ul><h3 id="表空间大小的限制"><a href="#表空间大小的限制" class="headerlink" title="表空间大小的限制"></a>表空间大小的限制</h3><p><img src="/2020/04/04/db2/%E8%A1%A8%E7%A9%BA%E9%97%B4%E5%A4%A7%E5%B0%8F.png" alt="表空间大小.png"></p><ul><li>表空间的大小是有上限的</li><li>表空间的页：4K,8K,16k,32k.</li></ul><h2 id="创建表空间"><a href="#创建表空间" class="headerlink" title="创建表空间"></a>创建表空间</h2><h3 id="创建表空间的语法"><a href="#创建表空间的语法" class="headerlink" title="创建表空间的语法"></a>创建表空间的语法</h3><p><img src="/2020/04/04/db2/%E5%88%9B%E5%BB%BA%E8%A1%A8%E7%A9%BA%E9%97%B4%E7%9A%84%E8%AF%AD%E6%B3%95_1.png" alt="创建表空间的语法_1.png"></p><p><img src="/2020/04/04/db2/%E5%88%9B%E5%BB%BA%E8%A1%A8%E7%A9%BA%E9%97%B4%E7%9A%84%E8%AF%AD%E6%B3%95_2.png" alt="创建表空间的语法_2.png"></p><h3 id="指定表空间类型和名称"><a href="#指定表空间类型和名称" class="headerlink" title="指定表空间类型和名称"></a>指定表空间类型和名称</h3><p><img src="/2020/04/04/db2/%E6%8C%87%E5%AE%9A%E8%A1%A8%E7%A9%BA%E9%97%B4%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%90%8D%E7%A7%B0.png" alt="指定表空间类型和名称.png"></p><ul><li>LARGE 创建大表空间</li><li>REGULAR 创建常规表空间</li><li>SYSTEM TEMPORARY 创建系统临时表空间</li><li>USER TEMPORARY 用户临时表空间</li><li>tablespace-name 指定表空间的名称，不能重名和以“SYS”开头</li></ul><h3 id="数据库分区组合数据页大小"><a href="#数据库分区组合数据页大小" class="headerlink" title="数据库分区组合数据页大小"></a>数据库分区组合数据页大小</h3><p><img src="/2020/04/04/db2/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%8C%BA%E7%BB%84%E5%90%88%E6%95%B0%E6%8D%AE%E9%A1%B5%E5%A4%A7%E5%B0%8F.png" alt="数据库分区组合数据页大小.png"></p><ul><li>DATABASE PARTITION GROUP db-partition-group-name 为表空间指定数据库分区组</li><li>PAGESIZE 指定表空间使用的数据页大小</li></ul><h3 id="表空间存储的管理方式和区大小"><a href="#表空间存储的管理方式和区大小" class="headerlink" title="表空间存储的管理方式和区大小"></a>表空间存储的管理方式和区大小</h3><p><img src="/2020/04/04/db2/%E8%A1%A8%E7%A9%BA%E9%97%B4%E5%AD%98%E5%82%A8%E7%9A%84%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F%E5%92%8C%E5%8C%BA%E5%A4%A7%E5%B0%8F.png" alt="表空间存储的管理方式和区大小.png"></p><ul><li>MANAGED BY 指定表空间存储的管理方式</li><li>EXTENTSIZE 指定表空间区的大小</li></ul><h3 id="预取页的大小与缓冲池"><a href="#预取页的大小与缓冲池" class="headerlink" title="预取页的大小与缓冲池"></a>预取页的大小与缓冲池</h3><p><img src="/2020/04/04/db2/%E9%A2%84%E5%8F%96%E9%A1%B5%E7%9A%84%E5%A4%A7%E5%B0%8F%E4%B8%8E%E7%BC%93%E5%86%B2%E6%B1%A0.png" alt="预取页的大小与缓冲池.png"></p><ul><li>PREFETCHSIZE 指定预取页的个数</li><li>BUFFERPOOL 指定表空间所使用的缓冲池</li></ul><h3 id="开销和传送速率"><a href="#开销和传送速率" class="headerlink" title="开销和传送速率"></a>开销和传送速率</h3><p><img src="/2020/04/04/db2/%E5%BC%80%E9%94%80%E5%92%8C%E4%BC%A0%E9%80%81%E9%80%9F%E7%8E%87.png" alt="开销和传送速率"></p><ul><li>用于确定查询优化期间的I/O成本，单位是毫秒</li><li>Overhead=平均寻道时间+（（（1/磁盘转速）*60 *1000）/2)</li><li>Transrate=(1/传送速率)* 1000 / 1024000 * 4096 (4096是指4k的页)</li></ul><h3 id="文件系统缓存和已删除表的恢复"><a href="#文件系统缓存和已删除表的恢复" class="headerlink" title="文件系统缓存和已删除表的恢复"></a>文件系统缓存和已删除表的恢复</h3><p><img src="/2020/04/04/db2/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%BC%93%E5%AD%98%E5%92%8C%E5%B7%B2%E5%88%A0%E9%99%A4%E8%A1%A8%E7%9A%84%E6%81%A2%E5%A4%8D.png" alt="文件系统缓存和已删除表的恢复"></p><ul><li>NO FILE SYSTEM CACHING 不使用文件系统的缓存特性</li><li>FILE SYSTEM CACHING 使用文件系统的缓存特性</li><li>DROPPED TABLE RECOVERY 设置是否启用已删除表的恢复特性</li></ul><h3 id="演示-1"><a href="#演示-1" class="headerlink" title="演示"></a>演示</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.切换到数据库实例：su - db2inst2</span><br><span class="line">2.启动数据库实例：db2start</span><br><span class="line">3.查看当前数据库实例管理哪些数据库：db2 list db directory</span><br><span class="line">4.连接数据库：db2 connect to jikedb1</span><br></pre></td></tr></table></figure><p>+++++++++++++++</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.创建表空间最简单的命令：</span><br><span class="line">  db2 create tablespace jikesimple;</span><br><span class="line">2.创建一个大型表空间：</span><br><span class="line">  db2 create large tablespace jikelarge;</span><br><span class="line">3.创建一个用户临时表空间：</span><br><span class="line">  db2 create user temporary tablespace jikeusertemp;</span><br><span class="line">4.创建一个8k页大小的表空间：</span><br><span class="line">  db2 create tablespace jike8k padesize 8k;</span><br><span class="line">5.创建一个数据库管理的表空间：</span><br><span class="line">  db2 &quot;create tablespace jikedms managed by database using (file &#39;&#x2F;dbpath&#x2F;jikedms01.dbf&#39; 10m,file &#39;&#x2F;dbpath.jikedms02.dbf&#39; 10m)&quot;;</span><br></pre></td></tr></table></figure><h2 id="维护表空间"><a href="#维护表空间" class="headerlink" title="维护表空间"></a>维护表空间</h2><h3 id="查看表空间"><a href="#查看表空间" class="headerlink" title="查看表空间"></a>查看表空间</h3><p><code>db2 list tablespaces [show detail]</code></p><p><img src="/2020/04/04/db2/%E6%9F%A5%E7%9C%8B%E8%A1%A8%E7%A9%BA%E9%97%B4.png" alt="查看表空间"></p><h3 id="查看表空间的容器"><a href="#查看表空间的容器" class="headerlink" title="查看表空间的容器"></a>查看表空间的容器</h3><p><code>db2 list tablespace containers for tablespace_id [show detail]</code></p><p><img src="/2020/04/04/db2/%E6%9F%A5%E7%9C%8B%E8%A1%A8%E7%A9%BA%E9%97%B4%E7%9A%84%E5%AE%B9%E5%99%A8.png" alt="查看表空间的容器"></p><h3 id="修改表空间"><a href="#修改表空间" class="headerlink" title="修改表空间"></a>修改表空间</h3><p><code>alter tablespace tablespace_name</code></p><p><img src="/2020/04/04/db2/%E4%BF%AE%E6%94%B9%E8%A1%A8%E7%A9%BA%E9%97%B4.png" alt="修改表空间"></p><h3 id="添加容器"><a href="#添加容器" class="headerlink" title="添加容器"></a>添加容器</h3><p><code>db2 alter tablespace tablespace_name add(device &#39;dev/rhd1&#39; 1000,device &#39;dev/rhd2&#39; 1000);</code></p><p><img src="/2020/04/04/db2/%E6%B7%BB%E5%8A%A0%E5%AE%B9%E5%99%A8.png" alt="添加容器.png"></p><h3 id="扩展容器"><a href="#扩展容器" class="headerlink" title="扩展容器"></a>扩展容器</h3><p><code>db2 alter tablespace tablespace_name extend (all 1000);</code></p><p><img src="/2020/04/04/db2/%E6%89%A9%E5%B1%95%E5%AE%B9%E5%99%A8.png" alt="扩展容器"></p><h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><p><code>db2 alter tablespace tablespace_name drop (file &#39;/db2path1/datafile1&#39;);</code></p><p><img src="/2020/04/04/db2/%E5%88%A0%E9%99%A4%E5%AE%B9%E5%99%A8.png" alt="删除容器"></p><h3 id="重命名表空间"><a href="#重命名表空间" class="headerlink" title="重命名表空间"></a>重命名表空间</h3><p><code>db2 rename tablespace_old to tablespace_new</code></p><p><img src="/2020/04/04/db2/%E9%87%8D%E5%91%BD%E5%90%8D%E8%A1%A8%E7%A9%BA%E9%97%B4.png" alt="重命名表空间"></p><h3 id="删除表空间"><a href="#删除表空间" class="headerlink" title="删除表空间"></a>删除表空间</h3><p><code>db2 drop tablespace_name</code></p><p><img src="/2020/04/04/db2/%E5%88%A0%E9%99%A4%E8%A1%A8%E7%A9%BA%E9%97%B4.png" alt="删除表空间"></p><h3 id="演示-2"><a href="#演示-2" class="headerlink" title="演示"></a>演示</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1.查看表空间</span><br><span class="line">  db2 list tablespaces</span><br><span class="line">  db2 list tablespaces detail</span><br><span class="line">2.查看表空间的容器</span><br><span class="line">  db2 list tablespace containers for 8</span><br><span class="line">  db2 list tablespace containers for 8 show detail</span><br><span class="line">3.为表空间添加一个容器</span><br><span class="line">  db2 &quot;alter tablespace jikedms add (file &#39;&#x2F;dbpath&#x2F;jikedms03.dbf&#39; 10m)&quot;</span><br><span class="line">4.修改容器的大小</span><br><span class="line">  db2 &quot;alter tablespace jikedms resize (file &#39;&#x2F;dbpath&#x2F;jikedms03.dbf&#39; 5m)&quot;</span><br><span class="line">5.删除容器</span><br><span class="line">  db2 &quot;alter tablespace jikedms drop (file &#39;&#x2F;dbpath&#x2F;jikedms03.dbf&#39;)&quot;</span><br><span class="line">6.重命名表空间</span><br><span class="line">  db2 rename tablespace jikedms to myjikedms;</span><br><span class="line">7.删除表空间</span><br><span class="line">  db2 drop tablespace myjikedms;</span><br></pre></td></tr></table></figure><h2 id="多温度存储器"><a href="#多温度存储器" class="headerlink" title="多温度存储器"></a>多温度存储器</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li>DB2 V10 中新增加的特性</li><li>将访问频率不同的数据放置在不同的存储空间中</li><li>引入了存储组（Storage Group)的概念</li><li>方便DBA对不同热度的数据进行管理</li></ul><h3 id="存储器组"><a href="#存储器组" class="headerlink" title="存储器组"></a>存储器组</h3><p><img src="/2020/04/04/db2/%E5%AD%98%E5%82%A8%E5%99%A8%E7%BB%84.png" alt="存储器组"></p><ul><li>存储数据的存储路径的集合</li><li>只有自动存储表空间才能使用存储器组</li><li>一个表空间只能与一个存储器组相关联</li><li>一个存储器组可以与多个表空间相关联</li></ul><h3 id="查看存储器组"><a href="#查看存储器组" class="headerlink" title="查看存储器组"></a>查看存储器组</h3><p><code>db2pd -db db_name -storagegroup</code></p><p><img src="/2020/04/04/db2/%E6%9F%A5%E7%9C%8B%E5%AD%98%E5%82%A8%E5%99%A8%E7%BB%84.png" alt="查看存储器组"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db2 &quot;select varchar(storage_group_name,20) as storage_group,</span><br><span class="line">     storage_group_id,</span><br><span class="line">     varchar(db_storage_path,20) as storage_path,</span><br><span class="line">     db_storage_path_state,</span><br><span class="line">     (fs_tatal_size &#x2F; 1000000) as total_path_MB,</span><br><span class="line">     (sto_path_free_size &#x2F; 1000000) as path_free_MB from </span><br><span class="line">     table(admin_get_storage_paths(&#39;&#39;,-1)) as T1&quot;;</span><br></pre></td></tr></table></figure><p><img src="/2020/04/04/db2/%E6%9F%A5%E7%9C%8B%E5%AD%98%E5%82%A8%E5%99%A8%E7%BB%84.png" alt="查看存储器组"></p><h3 id="创建存储器组"><a href="#创建存储器组" class="headerlink" title="创建存储器组"></a>创建存储器组</h3><p><img src="/2020/04/04/db2/%E5%88%9B%E5%BB%BA%E5%AD%98%E5%82%A8%E5%99%A8%E7%BB%84.png" alt="创建存储器组"></p><h3 id="删除存储器组"><a href="#删除存储器组" class="headerlink" title="删除存储器组"></a>删除存储器组</h3><p><code>db2 drop stogroup storage_group_name</code></p><p><img src="/2020/04/04/db2/%E5%88%A0%E9%99%A4%E5%AD%98%E5%82%A8%E5%99%A8%E7%BB%84.png" alt="删除存储器组"></p><h3 id="表空间与存储器组"><a href="#表空间与存储器组" class="headerlink" title="表空间与存储器组"></a>表空间与存储器组</h3><ul><li><p>一个表空间只能与一个存储器组相关联</p></li><li><p>一个存储器组可以与多个表空间相关联</p></li><li><p>创建表空间时可以指定存储器组</p><p>—<code>db2 create tablespace tablespace_name using stogroup storagegroup_name;</code></p></li><li><p>修改表空间使用存储器组</p><p>—<code>db2 alter tablespace tablespace_name using stogroup storagegroup_name;</code></p></li></ul><h3 id="查看表空间与存储器组的关系"><a href="#查看表空间与存储器组的关系" class="headerlink" title="查看表空间与存储器组的关系"></a>查看表空间与存储器组的关系</h3><p><code>db2 &quot;select TBSPACE,SGNAME,SGID from syscat.tablespaces&quot;;</code></p><p><img src="/2020/04/04/db2/%E6%9F%A5%E7%9C%8B%E8%A1%A8%E7%A9%BA%E9%97%B4%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8%E7%BB%84%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="查看表空间与存储器组的关系"></p><h3 id="演示-3"><a href="#演示-3" class="headerlink" title="演示"></a>演示</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1.查看存储器组</span><br><span class="line">  &#96;db2pd -db jikedb1 -storagegroup&#96;</span><br><span class="line">   db2 &quot;select varchar(storage_group_name,20) as storage_group,</span><br><span class="line">     storage_group_id,</span><br><span class="line">     varchar(db_storage_path,20) as storage_path,</span><br><span class="line">     db_storage_path_state,</span><br><span class="line">     (fs_tatal_size &#x2F; 1000000) as total_path_MB,</span><br><span class="line">     (sto_path_free_size &#x2F; 1000000) as path_free_MB from </span><br><span class="line">     table(admin_get_storage_paths(&#39;&#39;,-1)) as T1&quot;;</span><br><span class="line">2.创建存储器组</span><br><span class="line">  db2 &quot;create stogroup sql on &#39;&#x2F;home&#x2F;db2inst2&#x2F;sqpath1&#39;&quot;</span><br><span class="line">3.创建表空间，指定存储组</span><br><span class="line">  db2 create tablespace jikets1 using stogroup sql;</span><br><span class="line">4.查看表空间和存储器组的关系</span><br><span class="line">  db2 &quot;select TBSPACE.SGNAME.SGID from syscat.tablespaces&quot;;</span><br><span class="line">5.删除存储器组</span><br><span class="line">  db2 drop stogroup sql</span><br><span class="line">6.修改表空间的存储器组</span><br><span class="line">  db2 alter tablespace jikets1 using stogroup IBMSTOGROUP;</span><br></pre></td></tr></table></figure><h1 id="DB2数据库备份与恢复的相关概念"><a href="#DB2数据库备份与恢复的相关概念" class="headerlink" title="DB2数据库备份与恢复的相关概念"></a>DB2数据库备份与恢复的相关概念</h1><h2 id="备份的概念"><a href="#备份的概念" class="headerlink" title="备份的概念"></a>备份的概念</h2><h3 id="为什么要备份"><a href="#为什么要备份" class="headerlink" title="为什么要备份"></a>为什么要备份</h3><ul><li><p>数据丢失的情况：</p><p>—介质或存储器故障</p><p>—数据库实例崩溃</p><p>—应用程序错误</p><p>—灾难：地震、火灾等</p><p>—人员误操作</p></li></ul><h3 id="备份的层级"><a href="#备份的层级" class="headerlink" title="备份的层级"></a>备份的层级</h3><p><img src="/2020/04/04/db2/%E5%A4%87%E4%BB%BD%E7%9A%84%E5%B1%82%E7%BA%A7.png" alt="备份的层级"></p><ul><li>数据库</li><li>表空间</li><li>对象层</li><li>物理层</li></ul><h3 id="备份的类型"><a href="#备份的类型" class="headerlink" title="备份的类型"></a>备份的类型</h3><h4 id="脱机-离线（offline）备份×"><a href="#脱机-离线（offline）备份×" class="headerlink" title="脱机/离线（offline）备份×"></a>脱机/离线（offline）备份×</h4><ul><li>断开数据库的连接</li><li>备份时间短</li></ul><h4 id="在线（online）备份-√"><a href="#在线（online）备份-√" class="headerlink" title="在线（online）备份 √"></a>在线（online）备份 √</h4><ul><li>业务正常访问</li><li>备份时间相对较长</li></ul><h4 id="全量（full）备份"><a href="#全量（full）备份" class="headerlink" title="全量（full）备份"></a>全量（full）备份</h4><ul><li>备份数据库的所有数据</li></ul><h4 id="增量备份"><a href="#增量备份" class="headerlink" title="增量备份"></a>增量备份</h4><p>（cumulative\incremental backup)</p><ul><li>备份数据库最近成功全量备份后所有更改的数据</li></ul><p><img src="/2020/04/04/db2/%E5%A2%9E%E9%87%8F%E5%A4%87%E4%BB%BD.png" alt="增量备份"></p><h4 id="变量增量（Delta）备份"><a href="#变量增量（Delta）备份" class="headerlink" title="变量增量（Delta）备份"></a>变量增量（Delta）备份</h4><ul><li>备份最近一次成功备份后所有更改过的数据</li></ul><p><img src="/2020/04/04/db2/%E5%8F%98%E9%87%8F%E5%A2%9E%E9%87%8F%EF%BC%88Delta%EF%BC%89%E5%A4%87%E4%BB%BD.png" alt="变量增量（Delta）备份"></p><h4 id="全量备份、增量备份、delta备份的综合使用"><a href="#全量备份、增量备份、delta备份的综合使用" class="headerlink" title="全量备份、增量备份、delta备份的综合使用"></a>全量备份、增量备份、delta备份的综合使用</h4><p><img src="/2020/04/04/db2/%E5%A4%87%E4%BB%BD%E7%9A%84%E7%BB%BC%E5%90%88%E4%BD%BF%E7%94%A8.png" alt="备份的综合使用"></p><h2 id="恢复的概念"><a href="#恢复的概念" class="headerlink" title="恢复的概念"></a>恢复的概念</h2><h3 id="恢复的类型"><a href="#恢复的类型" class="headerlink" title="恢复的类型"></a>恢复的类型</h3><p><img src="/2020/04/04/db2/%E6%81%A2%E5%A4%8D%E7%9A%84%E7%B1%BB%E5%9E%8B.png" alt="恢复的类型"></p><h4 id="崩溃恢复"><a href="#崩溃恢复" class="headerlink" title="崩溃恢复"></a>崩溃恢复</h4><p><img src="/2020/04/04/db2/%E5%B4%A9%E6%BA%83%E6%81%A2%E5%A4%8D.png" alt="崩溃恢复"></p><ul><li><p>必须执行崩溃恢复的情况</p><p>—异常断电导致数据库管理器和数据库分区崩溃</p><p>—硬件故障，例如内存、磁盘、CPU或网络故障</p><p>—导致DB2实例异常结束的严重操作系统错误</p></li><li><p>崩溃恢复</p><p>—数据库异常结束，数据库管理器会自动启动崩溃恢复一尝试恢复数据库</p><p>—保护数据在事务（也称为工作单元）意外中断后不会处于不一致或不可用的状态</p></li></ul><h4 id="版本恢复"><a href="#版本恢复" class="headerlink" title="版本恢复"></a>版本恢复</h4><p><img src="/2020/04/04/db2/%E7%89%88%E6%9C%AC%E6%81%A2%E5%A4%8D.png" alt="版本恢复"></p><ul><li>使用备份操作期间创建的映像来复原数据库的先前版本</li><li>数据库备份使您可以将数据库复原到与进行备份使完全相同的状态</li><li>但是，从备份时间到故障时间之间的每个工作单元都将丢失</li></ul><h4 id="前滚恢复"><a href="#前滚恢复" class="headerlink" title="前滚恢复"></a>前滚恢复</h4><p><img src="/2020/04/04/db2/%E5%89%8D%E6%BB%9A%E6%81%A2%E5%A4%8D.png" alt="前滚恢复"></p><ul><li>要使用前滚恢复方法，必须已建立数据库的备份，并且使用了归档日志</li></ul><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h3><p><img src="/2020/04/04/db2/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E5%8A%A1" alt="什么是事务"></p><ul><li>一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单元</li><li>并发控制的基本单位</li></ul><h3 id="事务的ACID特性"><a href="#事务的ACID特性" class="headerlink" title="事务的ACID特性"></a>事务的ACID特性</h3><ul><li><p>原子性（Atomicity）</p><p>—一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节</p><p>—事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样</p></li><li><p>持久性(Durability)</p><p>—只要事务成功结束，它对数据库所做的更新就必须永久保存下来</p><p>—即使发生系统崩溃，重新启动数据库系统后，数据库还能恢复到事务成功结束时的状态</p></li><li><p>一致性（Consistency）</p><p>—一个事务执行之前和执行之后数据都必须处于一致性状态</p><p>—如果事务成功地完成，那么系统中所有变化将正确地应用，系统处于有效状态</p><p>—如果在事务中出现错误，那么系统中的所有变化将自动地回滚，系统返回到原始状态</p></li><li><p>隔离性（Isolation）</p><p>—在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间</p><p>—由并发事务所做的修改必须与任何其他并发事务所做的修改隔离</p><p>—事务查看数据更新时，数据所处的状态要么是另一事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看到中间状态的数据</p></li></ul><h2 id="DB2的日志"><a href="#DB2的日志" class="headerlink" title="DB2的日志"></a>DB2的日志</h2><h3 id="日志的机制与作用"><a href="#日志的机制与作用" class="headerlink" title="日志的机制与作用"></a>日志的机制与作用</h3><p><img src="/2020/04/04/db2/%E6%97%A5%E5%BF%97%E7%9A%84%E6%9C%BA%E5%88%B6%E4%B8%8E%E4%BD%9C%E7%94%A8.png" alt="日志的机制与作用"></p><h3 id="日志文件命名"><a href="#日志文件命名" class="headerlink" title="日志文件命名"></a>日志文件命名</h3><p><img src="/2020/04/04/db2/%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E5%91%BD%E5%90%8D.png" alt="日志文件命名"></p><ul><li><p>数据库管理器使用编号方案来命名日志文件</p></li><li><p>归纳日志的编号方案以S0000000.LOG开始，直到S9999999.LOG</p></li><li><p>如果发生以下情况，数据库管理器将复位到S0000000.LOG</p><p>—数据库配置文件更改为启动前滚恢复</p><p>—数据库配置文件更改为禁用前滚恢复</p><p>—已使用了S9999999.LOG</p></li><li><p>复用日志文件名</p></li></ul><h3 id="日志的类型"><a href="#日志的类型" class="headerlink" title="日志的类型"></a>日志的类型</h3><p><img src="/2020/04/04/db2/%E6%97%A5%E5%BF%97%E7%9A%84%E7%B1%BB%E5%9E%8B.png" alt="日志的类型"></p><ul><li><p>主日志</p><p>—数据库被激活后立即分配</p></li><li><p>辅助日志</p><p>—辅助日志在主日志大小不够的时候动态分配</p></li></ul><h3 id="日志的配置方式"><a href="#日志的配置方式" class="headerlink" title="日志的配置方式"></a>日志的配置方式</h3><h4 id="循环日志"><a href="#循环日志" class="headerlink" title="循环日志"></a>循环日志</h4><p><img src="/2020/04/04/db2/%E5%BE%AA%E7%8E%AF%E6%97%A5%E5%BF%97.png" alt="循环日志"></p><ul><li>创建新数据库时，循环日志记录是缺省行为</li><li>只允许完整的脱机/离线数据库备份</li><li>复原操作将数据恢复至进行完整备份的特定时间点，所以它称为版本恢复</li></ul><h4 id="归档日志"><a href="#归档日志" class="headerlink" title="归档日志"></a>归档日志</h4><p><img src="/2020/04/04/db2/%E5%BD%92%E6%A1%A3%E6%97%A5%E5%BF%97.png" alt="归档日志"></p><ul><li>归档日志记录专门用于前滚恢复</li><li>活跃日志是数据库当前使用的日志文件，包含有未提交的数据</li><li>在线的活跃日志包含在当前已提交，但是未写至容器的数据</li><li>已归档日志是指已从当前日志路径或镜像日志路径复制到其他位置的日志文件</li></ul><h3 id="与日志相关的参数"><a href="#与日志相关的参数" class="headerlink" title="与日志相关的参数"></a>与日志相关的参数</h3><ul><li><p>主日志文件（logprimary）</p><p>—指定将创建的主日志数</p><p>—主日志文件，无论是空的还是满的，都需要相同的磁盘空间容量</p></li><li><p>辅助日志（logsecond）</p><p>—创建并用于恢复（如果需要）的辅助日志文件的数目</p><p>—如果主日志文件已满，可按需要一次分配一个辅助日志文件</p><p>如果此参数设置为-1，那么将数据配置为无限活动日志空间</p></li><li><p>归档重试延迟（archretrydelay）</p><p>—指定在上一次尝试失败之后，归档日志文件尝试之间等待的时间量（以秒计），缺省值为20</p></li><li><p>日志磁盘已满时挂起（blk_log_dsk_ful）</p><p>—设置为YES,那么会导致应用程序在DB2数据库管理器遇到日志磁盘已满错误时挂起</p><p>—如果将blk_log_dsk_ful设置为NO,那么接受日志磁盘已满错误的事务将失败并被回滚</p></li><li><p>故障转移归档路径（failarchpath）</p><p>—常规归档路径存在问题（例如，如果该路径无法访问或已满），那么会为归档日志文件指定备用目录</p></li><li><p>主日志归档压缩（logarchcompr1）和辅助日志归档压缩（logarchcompr2）</p><p>—这些参数控制数据库管理器是否压缩归档日志文件。如果对日志归档文件进行压缩，那么可以减少与存储这些文件相关联的开销</p><p>—可设置为OFF(默认)或者 ON</p></li><li><p>日志归档方法1（logarchmeth1）、日志归档方法2（logarchmeth2）</p><p>—OFF(缺省值)：不使用日志归档方法</p><p>—LOGRETAIN: 活动日志文件文件保留并成为联机归档日志文件以用于前滚恢复</p><p>—USEREXIT: 日志保留日志记录并应使用用户出口程序来归档和检索这些日志文件</p><p>—DISK: 此值后必须紧跟冒号（:），然后是现有标准路径后，日志文件将在其中归档</p><p>—TSM: 不带有任何附加配置参数，那么此值指示应该使用缺省管理类，将日志文件归档在本地 </p><p>​              Tivoli Storage Manager(TSM) 服务器上。如果此值后紧跟冒号（:）和TSM管理类，那么使用指定的管理类来归档日志文件</p></li><li><p>日志缓冲区（logbufsz）</p><p>—将日志记录写至磁盘之前用作这些记录的缓冲区的内存量</p></li><li><p>日志文件大小（logfilsiz）</p><p>—此参数以4kb的页数指定每个配置日志的大小</p></li><li><p>每个事务的最大日志（max_log）</p><p>—指示一个事务可以消耗的主日志空间的百分比。该值是为logprimarg配置参数指定的值百分比</p></li><li><p>镜像日志路径（mirrorlogpath）</p><p>—防止主日志路径上的日志发生磁盘故障或被无意中删除的情况，可以指定在辅助（镜像）路径上维护完全相同的一组日志</p></li><li><p>新日志路径（newlogpath）</p><p>—指定数据库日志放置在另一目录或另一设备中</p></li><li><p>对组的落实次数（mincommit）</p><p>—延迟将日志记录写入磁盘，直到执行了最小数目的落实为主</p></li><li><p>事务可以跨越的活动日志数（num_log_span）</p><p>—此参数指示一个活动事务可以跨越的活动日志文件数。如果该值设置为0，那么对单个事务可以跨越的日志文件数没有限制</p><p>—如果应用程序违反了num_log_span设置，那么将强制该应用程序与数据库断开连接</p></li></ul><h1 id="DB2数据库与表空间的备份"><a href="#DB2数据库与表空间的备份" class="headerlink" title="DB2数据库与表空间的备份"></a>DB2数据库与表空间的备份</h1><h2 id="详解数据库与表空间的备份语法"><a href="#详解数据库与表空间的备份语法" class="headerlink" title="详解数据库与表空间的备份语法"></a>详解数据库与表空间的备份语法</h2><p><img src="/2020/04/04/db2/%E5%A4%87%E4%BB%BD%E8%AF%AD%E6%B3%95_01.png" alt="备份语法_01.png"></p><p>++++++++++++++++</p><ul><li>database-alias: 指定要备份的数据库的别名</li><li>username/using password: 指定备份数据库所使用的用户和用户密码</li></ul><p><img src="/2020/04/04/db2/%E5%A4%87%E4%BB%BD%E8%AF%AD%E6%B3%95_02.png" alt="备份语法_02"></p><ul><li>DBPARTITIONNUM db-partiton-number1：指定要备份的数据库分区的列表</li><li>DBPARTITIONNUMS db-partition-number1 TO db-partition-number2: 指定备份数据库分区的范围</li><li>ALL DBPARTITIONNUMS: 备份所有的数据库分区</li><li>EXCEPT: 要排除备份的数据库分区</li></ul><p><img src="/2020/04/04/db2/%E5%A4%87%E4%BB%BD%E8%AF%AD%E6%B3%95_03.png" alt="备份语法_03"></p><ul><li>TABLESPACE tablespace-name: 指定要备份的表空间</li><li>ONLINE: 指定对数据库进行在线的备份，默认是离线备份</li><li>INCREMENTAL: 对数据库进行增量备份</li><li>DELTA: 对数据库进行Delta备份</li></ul><p><img src="/2020/04/04/db2/%E5%A4%87%E4%BB%BD%E8%AF%AD%E6%B3%95_04.png" alt="备份语法_04"></p><ul><li><p>TSM： 使用 Tivoli Storage Manager 作为备份设置</p></li><li><p>OPEN SESSION: DB2与TSM或其他备份软件产品之间的IO会话数量</p><p>—注意：与 INCLUDE LOGS 参数的协同使用</p></li><li><p>TO dir | dev： 指定备份完成的数据文件所放置的路径或者设备</p></li></ul><p><img src="/2020/04/04/db2/%E5%A4%87%E4%BB%BD%E8%AF%AD%E6%B3%95_05.png" alt="备份语法_05"></p><ul><li>DEDUP_DEVICE: 如果使用数据复制的功能，此参数会优化备份文件在存储设备中存储格式</li><li>BUFFER buffer-size: DB2在备份过程中所占用的内存缓冲大小，以4k为单位</li><li>PARALLELISM n: 备份过程中，可以并发备份的表空间数量</li></ul><p><img src="/2020/04/04/db2/%E5%A4%87%E4%BB%BD%E8%AF%AD%E6%B3%95_06.png" alt="备份语法_06"></p><ul><li>COMPRESS | ENCRYPT 指定备份文件是使用压缩特征还是进行加密，两者不能同时使用</li></ul><p><img src="/2020/04/04/db2/%E5%A4%87%E4%BB%BD%E8%AF%AD%E6%B3%95_07.png" alt="备份语法_07"></p><ul><li><p>UTIL_IMPACT_PRIORITY priority: 指定备份操作的优先级</p><p>—可设置为1-100,1优先级最低，100优先级最高，默认是50</p></li><li><p>EXCLUDE LOGS: 指定备份过程中不备份日志文件</p><p>—对离线备份没有作用</p></li><li><p>INCLUDE LOGS: 指定备份过程中备份日志文件</p><p>—只针对在线备份有效</p></li></ul><p><img src="/2020/04/04/db2/%E5%A4%87%E4%BB%BD%E8%AF%AD%E6%B3%95_08.png" alt="备份语法_08"></p><ul><li>WITHOUT PROMPTING: 指定在备份过程中需不需要用户提供互输入</li></ul><p><img src="/2020/04/04/db2/%E5%A4%87%E4%BB%BD%E8%AF%AD%E6%B3%95_09.png" alt="备份语法_09"></p><h2 id="备份文件的命名惯例"><a href="#备份文件的命名惯例" class="headerlink" title="备份文件的命名惯例"></a>备份文件的命名惯例</h2><ul><li><p>数据库别名</p><p>—在调用备份实用程序是指定的，由1至8个字符组成的数据库别名</p></li><li><p>备份类型</p><p>—0 ：表示完整的数据库级别备份</p><p>—3 ：表示表空间级别的备份</p><p>—4 ：表示有 LOAD COPY YES 命令生成的备份映像</p><p><img src="/2020/04/04/db2/%E5%A4%87%E4%BB%BD%E7%B1%BB%E5%9E%8B.png" alt="备份类型"></p></li><li><p>实例名</p><p>—从 DB2INSTANCE 环境变量中提取的、由1到8个字符组成的当前实例名</p></li><li><p>数据库分区号</p><p>—在单一分区数据库环境中，分区号始终是 DBPART000</p><p>—在分区数据库环境中，它是DBPARTxxx,其中xxx是db2nodes.cfg文件中对数据库分区指定的编号</p><p><img src="/2020/04/04/db2/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%8C%BA%E5%8F%B7.png" alt="数据库分区号"></p></li><li><p>时间戳记</p><p>—执行备份操作时的日期和时间的14个字符表示法。该时间戳记得格式为yyyymmddhhnnss</p></li><li><p>序号</p><p>—用作文件扩展名的一个3位的数字</p></li></ul><p><img src="/2020/04/04/db2/%E5%BA%8F%E5%8F%B7.png" alt="序号"></p><h2 id="检查备份的完整性"><a href="#检查备份的完整性" class="headerlink" title="检查备份的完整性"></a>检查备份的完整性</h2><h3 id="db2ckbkp命令的作用"><a href="#db2ckbkp命令的作用" class="headerlink" title="db2ckbkp命令的作用"></a>db2ckbkp命令的作用</h3><ul><li><p>db2ckbkp</p><p>—检查备份文件的一致性以及备份文件的可用性</p><p>—也可用于显示备份文件的元数据</p></li></ul><h3 id="db2ckbkp的示例"><a href="#db2ckbkp的示例" class="headerlink" title="db2ckbkp的示例"></a>db2ckbkp的示例</h3><p><img src="/2020/04/04/db2/db2ckbkp%E7%9A%84%E7%A4%BA%E4%BE%8B.png" alt="db2ckbkp的示例"></p><h1 id="DB2数据库与表空间的恢复"><a href="#DB2数据库与表空间的恢复" class="headerlink" title="DB2数据库与表空间的恢复"></a>DB2数据库与表空间的恢复</h1><h2 id="恢复历史记录文件"><a href="#恢复历史记录文件" class="headerlink" title="恢复历史记录文件"></a>恢复历史记录文件</h2><h3 id="恢复历史记录文件的作用"><a href="#恢复历史记录文件的作用" class="headerlink" title="恢复历史记录文件的作用"></a>恢复历史记录文件的作用</h3><ul><li>包含当数据库的所有或部分必须恢复到给定时间点时，可用来确定恢复选项的备份信息的摘要</li><li>用来跟踪其他操作中与恢复相关的事件，如备份和复原操作</li><li>文件位于数据库目录中，文件名是 DB2RHIST.ASC及其备份 DB2RHIST.BAK</li><li>要查看恢复历史记录文件中的条目，可使用 LIST HISTORY 命令</li></ul><h3 id="哪些操作会更新恢复历史记录文件"><a href="#哪些操作会更新恢复历史记录文件" class="headerlink" title="哪些操作会更新恢复历史记录文件"></a>哪些操作会更新恢复历史记录文件</h3><ul><li><strong>备份</strong>了数控库或表空间</li><li><strong>复原</strong>了数据库或表空间</li><li><strong>前滚</strong>了数据库或表空间</li><li>自动<strong>重建</strong>了数据库，并且复原了多个映像</li><li><strong>创建</strong>了表空间</li><li><strong>改变</strong>了表空间</li><li><strong>停顿</strong>表空间</li><li><strong>重命名</strong>表空间</li><li><strong>装入</strong>表空间</li><li><strong>删除</strong>表（启用了恢复已废除的表，并且您正在使用可恢复日志记录）</li><li><strong>重组</strong>表</li><li>调用随需应变<strong>日志归档</strong></li><li><strong>写入</strong>新日志文件（使用可恢复日志记录时）</li><li><strong>归档</strong>日志文件（使用可恢复日志记录时）</li><li><strong>恢复</strong>数据库</li><li><strong>复原</strong>数据库或表空间操作失败</li></ul><h3 id="查看恢复历史记录文件的语法"><a href="#查看恢复历史记录文件的语法" class="headerlink" title="查看恢复历史记录文件的语法"></a>查看恢复历史记录文件的语法</h3><p><img src="/2020/04/04/db2/%E6%9F%A5%E7%9C%8B%E6%81%A2%E5%A4%8D%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%AD%E6%B3%95.png" alt="查看恢复历史记录文件的语法"></p><h3 id="查看恢复历史记录文件的示例"><a href="#查看恢复历史记录文件的示例" class="headerlink" title="查看恢复历史记录文件的示例"></a>查看恢复历史记录文件的示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.db2 list history since 19980201 for sample</span><br><span class="line">2.db2 list history backup containing userspace1 for sample</span><br><span class="line">3.db2 list history dropped table all for db sample</span><br><span class="line">4.db2 list history all for SAMPLE</span><br><span class="line">5.db2_all &quot;db2 list history since 20010601 for sample&quot;</span><br><span class="line">6.db2 list history since 20091020163200 for database sample</span><br></pre></td></tr></table></figure><p><img src="/2020/04/04/db2/%E6%9F%A5%E7%9C%8B%E6%81%A2%E5%A4%8D%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95%E6%96%87%E4%BB%B6%E7%9A%84%E7%A4%BA%E4%BE%8B.png" alt="查看恢复历史记录文件的示例"></p><h3 id="查看恢复历史记录文件的内容（Operation）"><a href="#查看恢复历史记录文件的内容（Operation）" class="headerlink" title="查看恢复历史记录文件的内容（Operation）"></a>查看恢复历史记录文件的内容（Operation）</h3><table><thead><tr><th align="left">A - Create table space</th><th>N - Rename table space</th></tr></thead><tbody><tr><td align="left">B - Backup</td><td>O - Drop table space</td></tr><tr><td align="left">C - Load copy</td><td>Q - Quiesce</td></tr><tr><td align="left">D - Drop table</td><td>R - Restore</td></tr><tr><td align="left">F - Rollforward</td><td>T - Alter table space</td></tr><tr><td align="left">G - Reorganize</td><td>U - Unload</td></tr><tr><td align="left">L - Load</td><td>X - Archive log</td></tr></tbody></table><h3 id="查看恢复历史记录文件的内容（Object）"><a href="#查看恢复历史记录文件的内容（Object）" class="headerlink" title="查看恢复历史记录文件的内容（Object）"></a>查看恢复历史记录文件的内容（Object）</h3><table><thead><tr><th>D - Database</th><th>T - Table</th></tr></thead><tbody><tr><td>I - Index</td><td>R - Partitioned table</td></tr><tr><td>P - Table space</td><td></td></tr></tbody></table><h3 id="查看恢复历史记录文件的内容（Type）"><a href="#查看恢复历史记录文件的内容（Type）" class="headerlink" title="查看恢复历史记录文件的内容（Type）"></a>查看恢复历史记录文件的内容（Type）</h3><ul><li><p>Alter table space operation types:</p><p>— C - Add container</p><p>— R - Rebalance</p></li><li><p>Archive log operation types:</p><p>— F - Failover archive path</p><p>— M - Secondary (mirror) log path</p><p>— N - Archive log command</p></li><li><p>Backup and restore operation types:</p><p>— D - Delta offline</p><p>— E - Delta online</p><p>— F - Offline</p><p>— I - Incremental offline</p><p>— M - Merged</p><p>— N - Online</p><p>— O -Incremental online</p><p>— R - Rebuild</p><p>— Z - Quiesce reset </p></li></ul><h2 id="数据库与表空间的恢复"><a href="#数据库与表空间的恢复" class="headerlink" title="数据库与表空间的恢复"></a>数据库与表空间的恢复</h2><h3 id="还原语法"><a href="#还原语法" class="headerlink" title="还原语法"></a>还原语法</h3><p><img src="/2020/04/04/db2/%E8%BF%98%E5%8E%9F%E8%AF%AD%E6%B3%95.png" alt="还原语法"></p><h3 id="分区数据库的还原"><a href="#分区数据库的还原" class="headerlink" title="分区数据库的还原"></a>分区数据库的还原</h3><ul><li>备份文件信息：</li></ul><p><img src="/2020/04/04/db2/%E5%A4%87%E4%BB%BD%E6%96%87%E4%BB%B6%E4%BF%A1%E6%81%AF.png" alt="备份文件信息"></p><ul><li>恢复方法：</li></ul><p><img src="/2020/04/04/db2/%E6%81%A2%E5%A4%8D%E6%96%B9%E6%B3%95.png" alt="恢复方法"></p><h3 id="增量备份的还原"><a href="#增量备份的还原" class="headerlink" title="增量备份的还原"></a>增量备份的还原</h3><p><img src="/2020/04/04/db2/%E5%A2%9E%E9%87%8F%E5%A4%87%E4%BB%BD%E7%9A%84%E8%BF%98%E5%8E%9F_1.png" alt="增量备份的还原_1"></p><p><img src="/2020/04/04/db2/%E5%A2%9E%E9%87%8F%E5%A4%87%E4%BB%BD%E7%9A%84%E8%BF%98%E5%8E%9F_2.png" alt="增量备份的还原_2"></p><h3 id="前滚语法"><a href="#前滚语法" class="headerlink" title="前滚语法"></a>前滚语法</h3><p><img src="/2020/04/04/db2/%E5%89%8D%E6%BB%9A%E8%AF%AD%E6%B3%95.png" alt="前滚语法"></p><h3 id="前滚语法的示例"><a href="#前滚语法的示例" class="headerlink" title="前滚语法的示例"></a>前滚语法的示例</h3><p><img src="/2020/04/04/db2/%E5%89%8D%E6%BB%9A%E8%AF%AD%E6%B3%95%E7%9A%84%E7%A4%BA%E4%BE%8B.png" alt="前滚语法的示例"></p><h2 id="数据库与表空间的恢复示例"><a href="#数据库与表空间的恢复示例" class="headerlink" title="数据库与表空间的恢复示例"></a>数据库与表空间的恢复示例</h2><h3 id="数据库恢复场景：完全恢复"><a href="#数据库恢复场景：完全恢复" class="headerlink" title="数据库恢复场景：完全恢复"></a>数据库恢复场景：完全恢复</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在测试表中插入测试数据：db2 &quot;insert into mytable values(2)&quot;</span><br><span class="line">在线备份数据库以及日志：db2 backup database testdb online include logs</span><br><span class="line">查看备份信息：db2 list history all for testdb</span><br><span class="line">恢复数据库：db2 restore database testdb taken at 20150520094119</span><br><span class="line">前滚数据库：db2 rollforward database testdb to end of logs and complete</span><br><span class="line">检查测试数据库：db2 &quot;select * from mytable&quot;</span><br></pre></td></tr></table></figure><h3 id="表空间恢复场景"><a href="#表空间恢复场景" class="headerlink" title="表空间恢复场景"></a>表空间恢复场景</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">恢复某个表空间：db2 &quot;restore database testdb tablespace (USERSPACE1) online&quot; taken at 20150520090420</span><br><span class="line">查看表空间状态：db2 list tablespace</span><br><span class="line">前滚表空间：db2 &quot;rollforward database testdb to end of logs and complete tablespace (USERSPACE1)&quot;</span><br><span class="line">查看表空间状态：db2 list tablespace</span><br></pre></td></tr></table></figure><h1 id="DB2中的数据库类型"><a href="#DB2中的数据库类型" class="headerlink" title="DB2中的数据库类型"></a>DB2中的数据库类型</h1><h2 id="为什么要将数据类型"><a href="#为什么要将数据类型" class="headerlink" title="为什么要将数据类型"></a>为什么要将数据类型</h2><ul><li>不同的属性用不同的数据类型进行定义</li></ul><p><img src="/2020/04/04/db2/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%B0%86%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png" alt="为什么要将数据类型"></p><h2 id="DB中的数据类型"><a href="#DB中的数据类型" class="headerlink" title="DB中的数据类型"></a>DB中的数据类型</h2><ul><li><p>DB2内置了 INTEGER、CHAR和DATE等基本数据类型</p></li><li><p>同时还提供创建<strong>用户自定义</strong>的数据类型（UDT）的工具，使用户能够创建复杂的非传统的数据类型，从而适应当今复杂的编程环境</p></li><li><p>内置的数据类型分为四类</p><p>—数字、字符串、日期时间和XML</p></li><li><p>用户自定义的数据类型分为：</p><p>—单值类型，结构化类型和引用类型</p></li></ul><p>++++++++++++</p><h3 id="数字数据类型"><a href="#数字数据类型" class="headerlink" title="数字数据类型"></a>数字数据类型</h3><h4 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h4><ul><li>整数：SMALLINT 、INTEGER 和 BiGINT 用来存储整数</li><li>SMALLINT 可以在 2 个字节中存储从 -32,768 到 32,767 的整数</li><li>INTEGER 可以在 4 个字节中存储从 -2,147,483,648 到 2,147,483,637 的整数</li><li>BIGINT 可以在 8 个字节中存储从 -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 的整数</li></ul><h4 id="小数"><a href="#小数" class="headerlink" title="小数"></a>小数</h4><ul><li><p>小数：DECIMAL用来存储有小数部分的数字</p></li><li><p>要定义这个数据类型，需要指定精度（p,表示<strong>总的位数</strong>）和小数位（s,表示<strong>小数点右边的位数</strong>）</p><p>—示例：定义 DECIMAL(10.2) 的列可以保存的金额最高可为 99999999.99</p><p>—数据库中需要的存储空间依赖于精度，按照公式 p/2+1 计算。所以 DECIMALL(10.2) 需要 10/2+1(即6)字节</p></li></ul><h4 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h4><ul><li>浮点数：REAL 和 DOUBLE 用来存储数字的近似值，适用于科学计量值</li><li>REAL： 保存<strong>单精度</strong>浮点数据类型例，最大长度为 4 字节。 指数表示</li><li>DOUBLE: 保存<strong>双精度</strong>浮点数据类型，需要 8 字节的存储空间</li><li>FLOAT: 可以视为 REAL 或 DOUBLE 的同义词</li></ul><h3 id="字符串数据类型"><a href="#字符串数据类型" class="headerlink" title="字符串数据类型"></a>字符串数据类型</h3><h4 id="单字节字符串"><a href="#单字节字符串" class="headerlink" title="单字节字符串"></a>单字节字符串</h4><ul><li><p>CHAR 或 CHARACTER</p><p>—CHAR 或 CHARACTER 用于保存<strong>固定长度</strong>（size）字节的字符串数据</p><p>—最大长度为254字节</p><p>—例如，人的性别，车牌号，身份证等</p></li><li><p>VARCHAR</p><p>—VARCHAR 用来存储<strong>可变长度</strong>的字符串</p><p>—VARCHAR 列的最大长度为 32,672 字节</p><p>—在数据库中，VARCHAR 数据只占用<strong>恰好所需</strong>的空间</p></li></ul><h4 id="双字节字符串"><a href="#双字节字符串" class="headerlink" title="双字节字符串"></a>双字节字符串</h4><ul><li>GRAPHIC 用来存储<strong>固定长度</strong>和<strong>双字节</strong>字符串。GRAPHIC 列的最大长度是 127个字符</li><li>VARGRAPHIC 用来存储<strong>可变长度</strong>的<strong>双字节</strong>字符串。VARGRAPHIC 列的最大长度是 16,336 个字节</li></ul><h4 id="长数据类型"><a href="#长数据类型" class="headerlink" title="长数据类型"></a>长数据类型</h4><ul><li><p>LONG VARCHAR</p><p>—LONG VARCHAR 允许的数据最大长度为 32700 字节</p><p>—有单独的存储区域，不需要使用 bufferpool</p></li><li><p>LONG VARGRAPHIC</p></li><li><p>CLOB(字符大对象)</p><p>—保存一本书的内容，将其作为表的一列</p></li><li><p>DBCLOB(双字节字符大对象)</p></li><li><p>BLOB(二进制大对象)</p><p>—保存二进制文件（图片）将其为做表的一列</p></li></ul><h3 id="日期时间数据类型"><a href="#日期时间数据类型" class="headerlink" title="日期时间数据类型"></a>日期时间数据类型</h3><ul><li><p>DB2提供了三种存储日期和时间的数据类型</p><p>—DATE<br>—TIME</p><p>—TIMESTAMP</p></li></ul><h3 id="XML数据类型"><a href="#XML数据类型" class="headerlink" title="XML数据类型"></a>XML数据类型</h3><ul><li>DB2 提供了XML数据类型来存储格式良好的XML文档</li><li>XML列中的值存储为与字符串数据类型不同的内部表示</li><li>要么XML数据类型的列中存储XML数据，需要使用XMLPARSE函数对数据进行转换</li></ul><h3 id="用户定义的数据类型"><a href="#用户定义的数据类型" class="headerlink" title="用户定义的数据类型"></a>用户定义的数据类型</h3><ul><li><p>DB2运行用户定义适合自己应有程序的数据类型</p></li><li><p>有三种用户定义的数据类型</p><p>—用户定义的单值类型</p><p>—用户定义的结构化类型</p><p>—用户定义的引用类型</p></li></ul><h1 id="表-1"><a href="#表-1" class="headerlink" title="表"></a>表</h1><ul><li>所有数据都存储在数据库的表中。表由不同数据类型的一列或多列组成。数据存储在行（或称为记录）中</li></ul><p><img src="/2020/04/04/db2/%E8%A1%A8.png" alt="表"></p><h2 id="创建表的示例1"><a href="#创建表的示例1" class="headerlink" title="创建表的示例1"></a>创建表的示例1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE employee(id INTEGER,</span><br><span class="line">                      name VARCHAR(10),</span><br><span class="line">                      gender CHAR(1))</span><br><span class="line">db2 describe table employee</span><br></pre></td></tr></table></figure><h2 id="创建表的示例2"><a href="#创建表的示例2" class="headerlink" title="创建表的示例2"></a>创建表的示例2</h2><ul><li>创建于另一张表结构相同的表</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE employee1 like employee</span><br><span class="line">db2 describe table employee1</span><br></pre></td></tr></table></figure><h2 id="创建表的示例3"><a href="#创建表的示例3" class="headerlink" title="创建表的示例3"></a>创建表的示例3</h2><ul><li>表存储在数据库的表空间中。表空间为表的存储提供物理空间。在创建表之前必须先创建表空间。</li><li>在创建表时，表放在默认的表空间内，也可以指定表存储在特定的表空间中。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db2 list tablespaces</span><br><span class="line">CREATE TABLE employee(ID INTEGER)</span><br><span class="line">IN USERSPACE1</span><br><span class="line">db2 &quot;select TABNAME,TBSPACE from syscat.tables where TABNAME &#x3D; &#39;EMPLOYEE2&#39;&quot;</span><br></pre></td></tr></table></figure><h2 id="修改表的示例1"><a href="#修改表的示例1" class="headerlink" title="修改表的示例1"></a>修改表的示例1</h2><ul><li>修改表结构或者列中的数据类型可以使用 ALTER TABLE 语句</li><li>例：为表添加新的一列</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE employee ADD depart id integer </span><br><span class="line">db2 describe table employee</span><br></pre></td></tr></table></figure><h2 id="修改表的示例2"><a href="#修改表的示例2" class="headerlink" title="修改表的示例2"></a>修改表的示例2</h2><ul><li>修改表某列的数据类型</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE employee ALTER names SET DATA TYPE </span><br><span class="line">VARCHAR(20) ALTER gender SET NO NULL</span><br><span class="line">db2 describe table employee</span><br></pre></td></tr></table></figure><h2 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h2><ul><li>删除表使用 drop table 语句</li><li>表从数据库中删除后，表中的数据和表定义都被删除。如果为表定义了索引或者约束，也会同时被删除</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop table employee</span><br></pre></td></tr></table></figure><h2 id="后续内容"><a href="#后续内容" class="headerlink" title="后续内容"></a>后续内容</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.常规表</span><br><span class="line">2.多维集群（MDC）表</span><br><span class="line">3.插入时间集群（ITC）表</span><br><span class="line">4.范围集群表（RCT）</span><br><span class="line">5.分区表</span><br><span class="line">6.临时表</span><br><span class="line">7.具体化查询表（MQT）</span><br><span class="line">8.影子表</span><br></pre></td></tr></table></figure><h1 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h1><h2 id="什么是约束"><a href="#什么是约束" class="headerlink" title="什么是约束"></a>什么是约束</h2><ul><li><p>DB2 可以限制存储在列中的数据的属性。这些特性被称为约束(constraint)或者规则(rule),数据库管理器会强制一到多个列遵守这些约束</p></li><li><p>比如：性别只能为男或女。薪资不能为负数。部门ID必须存在</p></li><li><p>DB2提供了三种类型的约束：</p><p>—唯一性约束、参照完整性约束和表检查约束</p></li></ul><p><img src="/2020/04/04/db2/%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%A6%E6%9D%9F.png" alt="什么是约束"></p><h2 id="唯一性约束"><a href="#唯一性约束" class="headerlink" title="唯一性约束"></a>唯一性约束</h2><ul><li>唯一性约束用于确保列中的值是唯一的。可以针对一个或多个列定义唯一性约束。唯一性约束中包括的每个列都必须定义为 NOT NULL</li><li>唯一性约束可以定义为 PRIMARY KEY 或 UNIQUE 约束。这些可以在创建表时作为 CREATE TABLE SQL 语句的一部分定义，或者在创建表后使用 ALTER TABLE 语句添加</li><li>什么时候应该定义  PRIMARY KEY ,什么时候应该定义 UNIQUE 键。DB2在一个表中只允许定义一个主键</li><li>比如员工ID,唯一的标识一个员工。所以可以将员工ID定义为主键。DB2在一个表中只允许定义一个主键</li><li>身份证列必须是唯一的，应该定义为 UNIQUE</li></ul><p><img src="/2020/04/04/db2/%E5%94%AF%E4%B8%80%E6%80%A7%E7%BA%A6%E6%9D%9F.png" alt="唯一性约束"></p><h2 id="唯一性约束示例"><a href="#唯一性约束示例" class="headerlink" title="唯一性约束示例"></a>唯一性约束示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE employee(emp_id integer NOT NULL PRIMARYKEY,</span><br><span class="line">                      name VARCHAR(10),</span><br><span class="line">                      gender CHAR(1),</span><br><span class="line">                      dep_id integer,</span><br><span class="line">                      pep_id CHAR(20) NOT NULL CONSTRAINT pepid UNIQUE,</span><br><span class="line">                      salary DECIMAL(10,2)</span><br><span class="line">                      )</span><br></pre></td></tr></table></figure><p><img src="/2020/04/04/db2/%E5%94%AF%E4%B8%80%E6%80%A7%E7%BA%A6%E6%9D%9F%E7%A4%BA%E4%BE%8B.png" alt="唯一性约束示例"></p><ul><li>先看例子再想为什么</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE employee ADD CONSTRAIN UNIQUE (emp_id)</span><br><span class="line">CREATE UNIQE INDEX iemployee ON employee (emp_id)</span><br></pre></td></tr></table></figure><ul><li>DB2 不允许在同样的列上创建多个唯一的索引。因此，不能再同样的列上同时定义 PRIMARYKEY 和 UNIQUE约束。</li><li>每当为列定义一个PRIMARYKEY 或 UNIQUE结束时，DB2都会创建一个唯一的索引以强制列的唯一性</li></ul><h2 id="参照完整性约束"><a href="#参照完整性约束" class="headerlink" title="参照完整性约束"></a>参照完整性约束</h2><ul><li>参照完整性约束用于定义表之间的约束关系并确保这些约束关系保存有效</li><li>拥有与另一个表相关的主键的表被称为夫表(parent table)。与父表相关的表被称为依赖表(dependent table)。可以为一个父表定义多个从属表</li><li>还可以定义同一个表中各行之间的关系。在这个情况下，父表和从属表时同一个表</li></ul><p><img src="/2020/04/04/db2/%E5%8F%82%E7%85%A7%E5%AE%8C%E6%95%B4%E6%80%A7%E7%BA%A6%E6%9D%9F.png" alt="参照完整性约束"></p><h2 id="参照完整性约束示例"><a href="#参照完整性约束示例" class="headerlink" title="参照完整性约束示例"></a>参照完整性约束示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE department(dep_id INTEGER NOT NULL PRIMARYKEY,</span><br><span class="line">                        name VARCHAR(20))</span><br><span class="line">CREATE TABLE employee(emp_id integer NOT NULL PRIMARYKEY,</span><br><span class="line">                      name VARCHAR(10)</span><br><span class="line">                      gender CHAR(1)</span><br><span class="line">                      dep_id interger not null,</span><br><span class="line">                      salary ECIMAL(10,2),</span><br><span class="line">                      foreign key(dep_id) references department(dep_id))</span><br><span class="line">insert into emplouee values(23,&#39;赵五&#39;,&#39;男&#39;,5,1000)</span><br></pre></td></tr></table></figure><h2 id="参照完整性约束-删除数据"><a href="#参照完整性约束-删除数据" class="headerlink" title="参照完整性约束-删除数据"></a>参照完整性约束-删除数据</h2><ul><li><p>当从父表中删除一行，而该行在从属表中有从属行时，DB2也强制实施一些规则。DB2采取的操作取决于为表定义的删除规则。可以指定四个规则：</p><p>RESTRICT、NO ACTION、CASCADE 和 SET NULL。</p></li><li><p>如果指定了 RESTRICT 或 NO ACTION ，那么DB2 不允许删除父行。必须首先删除从属表中的行才能删除父表中的行。这条规则是默认设置</p></li><li><p>如果指定了 CASCADE , 那么从父表中删除行时还会自动地删除所有从属表中的从属行。</p></li><li><p>如果指定了 SET NULL , 那么从父表中删除父行时从属行中的外键值被设置为空（如果可以为空的话）</p></li></ul><h2 id="表检查约束"><a href="#表检查约束" class="headerlink" title="表检查约束"></a>表检查约束</h2><ul><li>表检查约束用于确保列数据不违反为列定义的规则，并限制表的某一列中的值。DB2确保在插入和更新时不违反这些约束</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE employee ALTER gender CHAR(1) CHECK</span><br></pre></td></tr></table></figure><h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><ul><li>问题引入：有人能看到薪资，有人不能看到薪资</li><li>解决办法：为不同的用户创建不同的视图</li><li>视图允许不同的用户或应用程序以不同的方式查看同一张表中的数据</li><li>对于用户来说，视图看起来就像<strong>表一样</strong>。除视图定义之外，视图在数据库内并<strong>不占用空间</strong>；视图中显示的数据来自另一个表。可以根据现有的一个表（或多个表）、另一个视图或者表和视图的<strong>任意组合</strong>创建一个视图。在另一个视图的基础上定义的视图被称为<strong>嵌套视图</strong></li></ul><p><img src="/2020/04/04/db2/%E8%A7%86%E5%9B%BE.png" alt="视图.png"></p><h2 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h2><ul><li>创建视图可以使用 CREATE VIEW 语句。 SELECT 语句用于指定将在视图中显示哪些行与列</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE ADMINISTRATOR.EMPLOYEE(EMP_ID BIGINT NOT NULL,</span><br><span class="line">                                    NAME VARCHAR(10) NOT NULL,</span><br><span class="line">                                    GENDER CHARACTER(1) NOT NULL,</span><br><span class="line">                                    DEP_ID BIGINT NOT NULL,</span><br><span class="line">                                    SALART DECIMAL(5,2) NOT NULL);</span><br><span class="line">create view_common as select emp_id,name,gender from employee</span><br><span class="line">create view_manager as select * from employee</span><br></pre></td></tr></table></figure><p><img src="/2020/04/04/db2/%E8%A7%86%E5%9B%BE.png" alt="视图.png"></p><h2 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h2><ul><li>删除视图可以使用 DROP VIEW 语句</li><li>如果删除一个视图所基于的表或另一个视图，那么这个视图依然在数据库中被定义，但不会起作用</li><li>SYSCAT.VIEWS 的 VALID 列表明视图是有效的（“Y”）还是无效的（“X”）</li><li>即使重新创建基表，无效的视图仍然是无效的；必须也重新创建它</li></ul><h2 id="修改视图"><a href="#修改视图" class="headerlink" title="修改视图"></a>修改视图</h2><ul><li>视图不能修改；要更改视图定义，必须删除视图，然后重新创建它</li><li>DB2 提供的 ALTER VIEW 语句只用于修改引用类型</li></ul><h2 id="只读视图和可更新视图"><a href="#只读视图和可更新视图" class="headerlink" title="只读视图和可更新视图"></a>只读视图和可更新视图</h2><ul><li>在创建一个视图时，可以将它定义为<strong>只读视图</strong>或者<strong>可更新视图</strong></li><li>视图的<strong>SELECT 语句决定</strong>视图是只读的还是可更新的。一般情况下，如果视图中的行为可以映射到基表中的行，那么该视图就是可更新的。例如，前面示例中定义的 view_common 和 view_manager 视图就是可以更新的</li><li>创建可更新视图的规则很复杂，它们取决于查询的定义。例如：使用 VALUES 、DISTINCT 或 JOIN 特性的视图是不可更新的</li><li>通关查看 SYSCAT.VIEWS 的 <strong>READONLY</strong>列很容易就能确定视图时不是可更新的：Y 表示只读，N 表示非只读</li></ul><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><ul><li><p>索引是表的一个或多个列的键值的有序列表</p></li><li><p>如果没有索引：</p><p>—对表添加数据时，该数据将被追加到表的最后。不存在固有的数据顺序。搜索特定数据行时，必须检查从第一行到最后一行的所有行</p></li><li><p>创建索引的原因有两个：</p><p>—确保一个或多个列中值的唯一性</p><p>—提高表查询的性能。DB2优化器使用索引提高执行查询时的性能，或者以索引的顺序显示查询结果</p></li></ul><p><img src="/2020/04/04/db2/%E7%B4%A2%E5%BC%95.png" alt="索引.png"></p><ul><li><p>索引可以定义为唯一的或非唯一的</p><p>—非唯一的索引允许重复的键值</p><p>—唯一的索引只允许一个键值在列表中出现一次。唯一的索引允许出现单个空值。然而，第二个空值会导致重新现象，因此不允许</p></li><li><p>创建索引可以使用 <strong>CREATE INDEX</strong> 语句</p></li><li><p>为表中列指定 PRIMARY KEY 或 UNIQUE 约束，会隐式地创建索引</p></li><li><p>索引可以创建为升序、降序或双向。选择哪个选项取决于应用程序如何访问数据</p></li></ul><h2 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h2><ul><li><p>为员工ID创建索引</p><p>CREATE INDEX iemployee ON employee(id)</p></li><li><p>在默认情况下，索引按升序创建，但也可以创建降序索引。甚至可以为索引中的各个列指定不同的顺序</p><p>CREATE INDEX iemployee2 ON employee(id DESC,name ASC)</p></li><li><p>升序索引利于 MIN 列函数的结果；降序索引利于 MAX 列函数的结果。如果应用程序还需要数据按与索引相反的顺序排序，那么DB2允许创建双向索引</p><p>CREATE INDEX iemployee3 ON employee(id) ALLOW REVERSE SCANS</p></li></ul><h2 id="在索引中包含列"><a href="#在索引中包含列" class="headerlink" title="在索引中包含列"></a>在索引中包含列</h2><ul><li><p>在创建索引时，可以选择包含额外的列数据，这些额外的列数据将与键存储在一起，但实际上它们不是键本身的一部分，所以不被排序。在索引中包含额外列的主要原因是为了提高某些查询的性能：因为索引页面中已经提供了数据值，DB2就不需要访问数据页面。只能为唯一索引定义包含的列</p></li><li><p>假设我们经常做如下查询：</p><p>SELECT id,name FROM employee ORDER by id</p></li><li><p>建议创建如下索引：</p><p>CREATE UNIQUE INDEX iemployeeid ON employee (id) INCLUDE (name)</p></li><li><p>考虑：能否在索引中包含所有数据</p></li></ul><h2 id="创建索引时的考虑"><a href="#创建索引时的考虑" class="headerlink" title="创建索引时的考虑"></a>创建索引时的考虑</h2><ul><li>创建一个索引花费的时间较长。DB2必须读取每一行来提取键，对这些键进行排序，然后将键值列表写到数据库中。如果表比较大，那么将使用临时表空间对键进行排序</li><li>索引存储在表空间中。如果表驻留在数据库管理的表空间中，就可以选择将索引凡在不同的表空间中。在创建表时，可以使用 <strong>INDEXES IN</strong> 子句指定索引放置的表空间</li><li>索引是值的额外副本，所以当表中的数据被更新时，他们也必须被更新。如果表数据经常被更新，就要考虑额外的索引会对更新性能产生什么样的影响</li></ul><h2 id="索引的后续内容"><a href="#索引的后续内容" class="headerlink" title="索引的后续内容"></a>索引的后续内容</h2><ul><li><p>索引的分类</p><p>—唯一索引和非唯一索引</p><p>—集群索引和非集群索引</p><p>—分区索引和非分区索引</p><p>—双向索引</p><p>—基于表达式的索引</p></li></ul><h1 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h1><ul><li><p>触发器定义了一系列的操作，可以在对指定的表进行插入、更新或删除操作时自动执行这些操作</p></li><li><p>使用触发器的优点是：</p><p>—更快地开发应用程序：因为触发器存储在数据库中，所以不必编写触发器在每个应用程序中执行的操作</p><p>—更容易维护：定义了某个触发器后，那么当访问创建它所基于的表时，会自动调用该触发器</p><p>—业务规则的全局实现；如果业务策略更改，只需更改触发器而不必更改每个应用程序</p></li><li><p>创建触发器可以使用 <strong>CREATE TRIHHER</strong> 语句</p></li></ul><h2 id="触发器的分类"><a href="#触发器的分类" class="headerlink" title="触发器的分类"></a>触发器的分类</h2><ul><li><p>前触发器（BEFORE触发器）</p><p>—</p></li><li><p>后触发器（AFTER触发器）</p><p>—在更新、插入或删除操作后运行</p></li><li><p>BEFORE DELETE 触发器</p><p>—在删除操作前运行</p></li><li><p>INSTEAD OF 触发器</p><p>—INSTEAD OF 触发器描述如何对复杂视图执行插入、更新和删除操作</p></li></ul><p>INSTEAD OF 触发器允许应用程序将视图用作所有SQL操作（插入、删除、更新和选择）的唯一界面</p><h2 id="触发器示例"><a href="#触发器示例" class="headerlink" title="触发器示例"></a>触发器示例</h2><ul><li>示例：sample 数据库自带的min_salary触发器</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER min_salary NO CASCADE</span><br><span class="line">BEFORE INSERT ON staff</span><br><span class="line">REFERENCING NEW AS newstaff</span><br><span class="line">FOR EACH ROW MODE DB2SQL</span><br><span class="line">BEGIN ATOMIC</span><br><span class="line">SET newstaff.salary &#x3D; CASE</span><br><span class="line">WHEN newstaff.job &#x3D; &#39;Mgr&#39; AND newstaff.salary &lt; 17000.00</span><br><span class="line">THEN 17000.00</span><br><span class="line">WHEN newstaff.job &#x3D; &#39;Sales&#39; AND newstaff.salary &lt; 14000.00</span><br><span class="line">THEN 14000.00</span><br><span class="line">WHEN newstaff.job &#x3D; &#39;Clerk&#39; AND newstaff.salary &lt; 10000.00</span><br><span class="line">THEN 10000.00</span><br><span class="line">ELSE newstaff.salary</span><br><span class="line">END;</span><br><span class="line">END</span><br></pre></td></tr></table></figure><h1 id="DB2-SQL"><a href="#DB2-SQL" class="headerlink" title="DB2 SQL"></a>DB2 SQL</h1><h2 id="SQL简介"><a href="#SQL简介" class="headerlink" title="SQL简介"></a>SQL简介</h2><h3 id="SQL简介-1"><a href="#SQL简介-1" class="headerlink" title="SQL简介"></a>SQL简介</h3><p><img src="/2020/04/04/db2/SQL%E7%AE%80%E4%BB%8B.png" alt="SQL简介"></p><h3 id="SQL的分类"><a href="#SQL的分类" class="headerlink" title="SQL的分类"></a>SQL的分类</h3><ul><li><p>SQL语句主要分为6个部分：</p></li><li><p>1、数据查询语言（DQL:Data Query Language）:</p><p>—从数据中查询数据。关键字是 <strong>SELECT</strong> ,以及相关的谓词如 <strong>WHERE,ORDER BY,GROUP BY和HAVING</strong>等</p></li><li><p>2、数据操作语言（DML:Data Manipulation Language）:</p><p>—关键字是<strong>INSERT,UPDATE和DELETE</strong>等</p></li><li><p>3、事务处理语言（TPL）:</p><p>—用以实现事务操作。TPL语句包括<strong>BEGIN TRANSACTION,COMMIT和ROLL BACK</strong></p></li><li><p>4、数据控制语言（DCL）：</p><p>—DCL一般实现数据库的权限控制。关键字是<strong>GRANT或REVOKE</strong>获得许可</p></li><li><p>5、数据定义语言（DDL）：</p><p>—关键字是：<strong>CREATE和DROP</strong></p></li><li><p>6、指针控制语言（CCL）：</p><p>—*<em>DECLARE CURSOR,FETCH INTO 和 UPDATE WHERE CURRENT *</em>用于对一个或多个表单独行的操作</p></li></ul><h2 id="SQL中查询操作"><a href="#SQL中查询操作" class="headerlink" title="SQL中查询操作"></a>SQL中查询操作</h2><h3 id="SELECT语句"><a href="#SELECT语句" class="headerlink" title="SELECT语句"></a>SELECT语句</h3><ul><li><p>SELECT语句用于查询表或者视图中的数据</p></li><li><p>查询子句</p><p>— FROM : 指定要查询的表</p><p>— WHERE : 指定查询条件</p><p>— GROUP BY : 分组</p><p>— HAVING : 可以和函数一起使用</p><p>— SELECT : 子查询</p><p>— ORDER BY : 排序</p><p>— FETCH FIRST : 查询前几行</p></li></ul><h4 id="SELECT语句示例"><a href="#SELECT语句示例" class="headerlink" title="SELECT语句示例"></a>SELECT语句示例</h4><ul><li><p>查询所有的数据</p><p>—SELECT * FROM employee</p></li><li><p>使用 FETCH FIRST 限制结果集中行的数量</p><p>—SELECT * FROM employee FETCH FIRST 10 ROWS ONLY</p></li><li><p>查询表中的指定列</p><p>—SELECT firstnme,salary FROM employee</p></li><li><p>使用 DISTINCT 消除结果集中的重复行</p><p>—SELECT DISTINCT sex,job FROM employee</p></li><li><p>使用 AS 子句给选择列表中的表达式或项目分配一个有意义的名称</p><p>—SELECT firstnme,salary + comm AS pay FROM employee</p></li></ul><h3 id="WHERE子句"><a href="#WHERE子句" class="headerlink" title="WHERE子句"></a>WHERE子句</h3><ul><li>在SELECT查询中可以使用WHERE子句指定一个或多个搜索过滤条件，从而从表或试图选择特定的行</li></ul><h4 id="WHERE子句示例"><a href="#WHERE子句示例" class="headerlink" title="WHERE子句示例"></a>WHERE子句示例</h4><ul><li><p>寻找工资超过30,000的职员的姓名</p><p>—SELECT firstnme,salary FROM employee WHERE salary &gt;30000</p></li><li><p>列出工资超过30,000的不是经理的职员的姓名、头衔和工资</p><p>—SELECT firstnme,job,salary FROM employee WHERE job &lt;&gt; ‘MANAGER’ AND salary &gt;30000</p></li><li><p>寻找以字母K开头的所有姓名</p><p>—SELECT name FROM employee WHERE name LIKE ‘K%’</p></li></ul><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><ul><li><p>子查询（subquery）是在主查询的 WHERE 子句中出现的 SELECT 语句，它将结果集提供给 WHERE 子句</p></li><li><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT lastname FROM employee</span><br><span class="line"></span><br><span class="line">WHERE lastname IN</span><br><span class="line"></span><br><span class="line">(SELECT sales_person FROM sales</span><br><span class="line"></span><br><span class="line">WHERE sales_date &lt; &#39;03&#x2F;03&#x2F;1996&#39;)</span><br></pre></td></tr></table></figure></li></ul><h3 id="相关名称-别名"><a href="#相关名称-别名" class="headerlink" title="相关名称-别名"></a>相关名称-别名</h3><ul><li><p>相关名称（correlation name）是指在查询的 FROM 子句中可以对表定义一个表的简短名称</p></li><li><p>相关名称还可以消除对来自不同表的相同列名的二义性引用</p></li><li><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT e.salary FROM employee e</span><br><span class="line">WHERE e.salary &lt;</span><br><span class="line">(SELECT AVG(s.salary) FROM employee s)</span><br></pre></td></tr></table></figure></li></ul><h3 id="ORDER-BY-子句"><a href="#ORDER-BY-子句" class="headerlink" title="ORDER BY 子句"></a>ORDER BY 子句</h3><ul><li><p>ORDER BY 子句可以根据一个或多个列中的值对结果集进行排序</p></li><li><p>注意：ORDER BY 子句中指定的列名不一定在选择列表中指定</p></li><li><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT firstnme,salary FROM employee</span><br><span class="line">WHERE salary &gt; 30000</span><br><span class="line">ORDER BY salary ASC</span><br></pre></td></tr></table></figure></li><li><p>在 ORDER BY 子句中指定 DESC 可以对结果集进行降序排序</p><p>—ORDER BY salary DESC</p></li></ul><h3 id="GROUP-BY-子句"><a href="#GROUP-BY-子句" class="headerlink" title="GROUP BY 子句"></a>GROUP BY 子句</h3><ul><li><p>GROUP BY 子句可以对结果集进行分组。每个组在结果集中用一行来表示</p></li><li><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT MAX(EMPLOYEE.SALARY),EMPLOYEE.WORKDEPT</span><br><span class="line">FROM ADMINISTRATOR.EMPLOYEE AS EMPLOYEE</span><br><span class="line">GROUP BY EMPLOYEE.WORKDEPT</span><br></pre></td></tr></table></figure></li></ul><h2 id="SQL中的插入、更新与删除操作"><a href="#SQL中的插入、更新与删除操作" class="headerlink" title="SQL中的插入、更新与删除操作"></a>SQL中的插入、更新与删除操作</h2><h3 id="INSERT语句"><a href="#INSERT语句" class="headerlink" title="INSERT语句"></a>INSERT语句</h3><ul><li><p>INSERT语句可以在表或者视图中添加新的记录。并且在视图中插入一个新行也会视图基于的表中插入这一行</p></li><li><p>示例：为表中插入两条数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO ADMINISTRATOR.EMPLOYEE1(EMP_ID,SALARY,NAME,GENDER,DEP_ID)</span><br><span class="line">VALUES (2,23.23,&#39;张三&#39;,&#39;M&#39;,2)</span><br><span class="line">INSERT INTO ADMINISTRATOR.EMPLOYEE1(EMP_ID,SALARY,NAME,GENDER,DEP_ID)</span><br><span class="line">VALUES (3,33.323,&#39;李四&#39;,&#39;M&#39;,2)</span><br><span class="line">或：</span><br><span class="line">INSERT INTO ADMINISTRATOR.EMPLOYEE1(EMP_ID,SALARY,NAME,GENDER,DEP_ID)</span><br><span class="line">VALUES (2,23.23,&#39;张三&#39;,&#39;M&#39;,2),(3,33.323,&#39;李四&#39;,&#39;M&#39;,2)</span><br></pre></td></tr></table></figure></li><li><p>可以通过SQL语句复制其他表或者视图中的数据导入到某张表中</p></li><li><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE pers LIKE employee</span><br><span class="line">或：</span><br><span class="line">INSERT INTO pers SELECT * FROM employee WHERE job &#x3D; &#39;MANAGER&#39;</span><br></pre></td></tr></table></figure></li><li><p>思考：如果要导入一万条甚至更多的数据，如何解决？</p></li></ul><h3 id="UPDATE语句"><a href="#UPDATE语句" class="headerlink" title="UPDATE语句"></a>UPDATE语句</h3><ul><li><p>UPDATE语句用于修改表或视图中的数据</p></li><li><p>通过指定 WHERE 子句，可以修改满足条件的数据值</p></li><li><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATE employee SET workdept &#x3D; &#39;C01&#39;,salary &#x3D; 70000 WHERE empno &#x3D; 20</span><br><span class="line">或</span><br><span class="line">UPDATE employee SET (Workdept,salary)&#x3D;(&#39;C01&#39;,70000) WHERE empno &#x3D; 20</span><br></pre></td></tr></table></figure></li><li><p>重要提醒：如果不加WHERE子句会怎么样？</p></li></ul><h3 id="DELETE语句"><a href="#DELETE语句" class="headerlink" title="DELETE语句"></a>DELETE语句</h3><ul><li><p>DELETE语句用来从表中删除整行的数据</p></li><li><p>指定 WHERE 子句，可以删除满足条件的每一行</p></li><li><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELECT FROM employ WHERE empno IN (20,30)</span><br></pre></td></tr></table></figure></li><li><p>重要提醒：如果不指定WHERE子句会怎么样？</p><p>会删除表里所有数据，变成空表。</p></li></ul><h1 id="DB2数据的导入与导出"><a href="#DB2数据的导入与导出" class="headerlink" title="DB2数据的导入与导出"></a>DB2数据的导入与导出</h1><h2 id="DB2数据导入导出工具介绍"><a href="#DB2数据导入导出工具介绍" class="headerlink" title="DB2数据导入导出工具介绍"></a>DB2数据导入导出工具介绍</h2><h3 id="DB2数据移动程序"><a href="#DB2数据移动程序" class="headerlink" title="DB2数据移动程序"></a>DB2数据移动程序</h3><ul><li><p>DB2中提供了三个用于数据移动的程序：</p><p>—EXPORT : 使用 SQL SELECT 语句将数据从数据库表中提取到一个文件中</p><p>—IMPORT : 将输入文件中的数据导入到表中</p><p>—LOAD : 将输入文件中的数据导入到表中的另外一个高效方法</p></li></ul><h3 id="文件格式-ASC"><a href="#文件格式-ASC" class="headerlink" title="文件格式-ASC"></a>文件格式-ASC</h3><ul><li><p>非定界的或固定长度的ASCII(ASC):</p><p>—这种文件类型包含<strong>固定长度</strong>的ASCII数据，这些数据与列数据相对应</p><p>—每个ASC文件都是一个ASCII字符流，其中包含<strong>按行和列排列</strong>的数据值</p><p>—数据库中的<strong>行一行分解符分隔开来</strong>，这里假定行分界符就是<strong>换行符</strong></p><p>—<strong>适用于数据的导入操作，不能用做导出操作</strong></p><p><img src="/2020/04/04/db2/%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F-ASC.png" alt="文件格式-ASC"></p></li></ul><h3 id="文件格式-DEL"><a href="#文件格式-DEL" class="headerlink" title="文件格式-DEL"></a>文件格式-DEL</h3><ul><li><p>定界的ASCII(DEL):</p><p>—<strong>最为常用</strong>的一种文件格式</p><p>—<strong>可用于数据的导入和导出操作</strong></p><p>—包含ASCII数据，并使用<strong>特殊的字符分界符</strong>来分隔列值</p><p>—数据流中的行则以作为行分界符的换行字符分隔开来，默认为换行</p><p><img src="/2020/04/04/db2/%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F-DEL.png" alt="文件格式-DEL.png"></p></li></ul><h3 id="文件格式-PC-IXF"><a href="#文件格式-PC-IXF" class="headerlink" title="文件格式-PC/IXF"></a>文件格式-PC/IXF</h3><ul><li><p>PC版本的 集成交换格式 Integrated Exchange Format (PC/IXF)</p><p>—导出的文件中包含数据库表的结构化描述</p><p>—可用于导入数据，还可以用于创建目标数据库中之前不存在的表</p><p>—可用于数据的导入和导出</p><p>—导出文件是二进制</p></li></ul><h3 id="文件格式-WSF"><a href="#文件格式-WSF" class="headerlink" title="文件格式-WSF"></a>文件格式-WSF</h3><ul><li><p>工作表格式（WSF):</p><p>—存储在工作表（一般用于Lotus）中解释</p><p>—可用于导出和导入</p></li></ul><h2 id="DB2导出工具的使用"><a href="#DB2导出工具的使用" class="headerlink" title="DB2导出工具的使用"></a>DB2导出工具的使用</h2><h2 id="DB2导入工具的使用"><a href="#DB2导入工具的使用" class="headerlink" title="DB2导入工具的使用"></a>DB2导入工具的使用</h2>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> db2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo使用手册</title>
      <link href="/2020/03/31/hexo%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/"/>
      <url>/2020/03/31/hexo%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p> 简单了解hexo个人静态博客的使用…</p><a id="more"></a><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p><code>hexo g</code>重新编辑本地博客</p><p><code>hexo s</code>本地运行博客（默认端口运行）</p><ul><li><code>hexo s -p 5000</code>  端口：5000的本地运行</li><li><code>Ctrl + C</code>结束本地运行（Y）</li></ul><p><code>hexo d</code>上传到github上</p><h3 id="编写文章"><a href="#编写文章" class="headerlink" title="编写文章"></a>编写文章</h3><!--在博客路径下输入cmd命令：--><p><code>hexo n &#39;文章名称&#39;</code>创建文章</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">title: &#39;hexo使用手册&#39;</span><br><span class="line">date: 2020-03-31 16:05:59</span><br><span class="line">categories: hexo入门   --分类</span><br><span class="line">tags:                 --标签</span><br><span class="line"> -hexo</span><br><span class="line"> -...</span><br></pre></td></tr></table></figure><h4 id="首页文章截取"><a href="#首页文章截取" class="headerlink" title="首页文章截取"></a>首页文章截取</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">《简介》</span><br><span class="line">  &lt;!--more--&gt;</span><br></pre></td></tr></table></figure><h3 id="上传图片"><a href="#上传图片" class="headerlink" title="上传图片"></a>上传图片</h3><p>安装图片插件</p><p><img src="/2020/03/31/hexo%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/a.jpg" alt></p><p>在_config.yml配置文件中，修改为 post_asset_folder: true， 然后新建一篇文章，然后会生成xx.md及xx文件夹‘用于存放图片’</p><p><img src="/2020/03/31/hexo%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/b.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">存放图片形式以相对路径（md编辑时无法显示图片）：</span><br><span class="line">![图片描述](a.jpg)</span><br></pre></td></tr></table></figure><h1 id="hexo-样式优化"><a href="#hexo-样式优化" class="headerlink" title="hexo 样式优化"></a>hexo 样式优化</h1><p><a href="http://shenzekun.cn/hexo的next主题个性化配置教程.html" target="_blank" rel="noopener">点我设置样式“Moorez”</a></p>]]></content>
      
      
      <categories>
          
          <category> hexo入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
